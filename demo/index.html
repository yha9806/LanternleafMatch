<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>ç¯ç¬¼å¶å­æ¶ˆæ¶ˆä¹ - Demo</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: linear-gradient(135deg, #2d5a27 0%, #1a3518 100%);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      color: #fff;
      overflow: hidden;
    }
    .header {
      padding: 20px;
      text-align: center;
      width: 100%;
      max-width: 600px;
    }
    .title {
      font-size: 28px;
      font-weight: bold;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
      margin-bottom: 10px;
    }
    .hud {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 20px;
      background: rgba(255,255,255,0.15);
      border-radius: 12px;
      margin-bottom: 15px;
    }
    .hud-item {
      text-align: center;
    }
    .hud-label {
      font-size: 12px;
      opacity: 0.8;
    }
    .hud-value {
      font-size: 24px;
      font-weight: bold;
    }
    .goal-box {
      background: rgba(255,255,255,0.1);
      padding: 8px 16px;
      border-radius: 8px;
      font-size: 14px;
    }
    #gameCanvas {
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
      touch-action: none;
    }
    .controls {
      margin-top: 20px;
      display: flex;
      gap: 12px;
    }
    .btn {
      padding: 12px 24px;
      font-size: 16px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      transition: transform 0.1s, box-shadow 0.1s;
    }
    .btn:active {
      transform: scale(0.95);
    }
    .btn-primary {
      background: linear-gradient(135deg, #ffd700, #ffb800);
      color: #333;
      box-shadow: 0 4px 12px rgba(255,215,0,0.4);
    }
    .btn-secondary {
      background: rgba(255,255,255,0.2);
      color: #fff;
    }
    .message {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.85);
      padding: 30px 50px;
      border-radius: 16px;
      text-align: center;
      display: none;
      z-index: 100;
    }
    .message h2 {
      font-size: 32px;
      margin-bottom: 15px;
    }
    .message p {
      font-size: 18px;
      opacity: 0.8;
      margin-bottom: 20px;
    }
    .message-buttons {
      display: flex;
      gap: 10px;
      justify-content: center;
      flex-wrap: wrap;
    }
    .energy-bar {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .energy-icon {
      font-size: 20px;
    }
    .combo-text {
      position: fixed;
      top: 40%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 48px;
      font-weight: bold;
      color: #ffd700;
      text-shadow: 0 0 20px rgba(255,215,0,0.8);
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
    }
    .energy-timer {
      font-size: 11px;
      opacity: 0.7;
      text-align: center;
    }
    .newbie-hint {
      background: linear-gradient(135deg, #4CAF50, #2E7D32);
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 12px;
      text-align: center;
      margin-top: 8px;
      animation: pulse 2s infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    .energy-gate {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.9);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 200;
    }
    .energy-gate-content {
      text-align: center;
      padding: 30px;
    }
    .energy-gate h2 {
      font-size: 28px;
      margin-bottom: 20px;
    }
    .energy-gate p {
      font-size: 16px;
      opacity: 0.8;
      margin-bottom: 10px;
    }
    .energy-gate .big-icon {
      font-size: 64px;
      margin-bottom: 20px;
    }
    .energy-gate .btn {
      margin: 10px;
      min-width: 150px;
    }
    .btn-ad {
      background: linear-gradient(135deg, #9C27B0, #7B1FA2);
      color: #fff;
      box-shadow: 0 4px 12px rgba(156,39,176,0.4);
    }
    .ad-remaining {
      font-size: 12px;
      opacity: 0.6;
      margin-top: 8px;
    }
    /* é“å…·æ æ ·å¼ */
    .item-bar {
      display: flex;
      gap: 8px;
      margin-top: 15px;
      padding: 10px 15px;
      background: rgba(255,255,255,0.1);
      border-radius: 12px;
    }
    .item-slot {
      position: relative;
      width: 50px;
      height: 50px;
      background: rgba(255,255,255,0.15);
      border-radius: 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: transform 0.1s, background 0.2s;
    }
    .item-slot:hover:not(.locked):not(.disabled) {
      background: rgba(255,255,255,0.25);
      transform: scale(1.05);
    }
    .item-slot:active:not(.locked):not(.disabled) {
      transform: scale(0.95);
    }
    .item-slot.locked {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .item-slot.disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    .item-slot.active {
      background: rgba(255,215,0,0.4);
      box-shadow: 0 0 10px rgba(255,215,0,0.6);
    }
    .item-slot.cooldown {
      opacity: 0.7;
    }
    .item-icon {
      font-size: 22px;
    }
    .item-count {
      position: absolute;
      bottom: 2px;
      right: 4px;
      font-size: 11px;
      font-weight: bold;
      background: rgba(0,0,0,0.5);
      padding: 1px 4px;
      border-radius: 6px;
    }
    .item-lock {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 16px;
    }
    .item-cooldown {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 3px;
      background: rgba(255,215,0,0.8);
      border-radius: 0 0 10px 10px;
      transform-origin: left;
      transform: scaleX(0);
    }
    .item-tooltip {
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.9);
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 12px;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
    }
    .item-slot:hover .item-tooltip {
      opacity: 1;
    }
    /* å¥–åŠ±å¼¹çª— */
    .reward-popup {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, #1a3518, #2d5a27);
      border: 3px solid #ffd700;
      border-radius: 16px;
      padding: 25px 35px;
      text-align: center;
      z-index: 150;
      display: none;
      animation: popIn 0.3s ease-out;
    }
    @keyframes popIn {
      from { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
      to { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    }
    .reward-popup h3 {
      color: #ffd700;
      font-size: 20px;
      margin-bottom: 15px;
    }
    .reward-items {
      display: flex;
      gap: 15px;
      justify-content: center;
      margin-bottom: 15px;
    }
    .reward-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
    }
    .reward-item .icon {
      font-size: 28px;
    }
    .reward-item .amount {
      font-size: 14px;
      color: #4CAF50;
      font-weight: bold;
    }
    .reward-buttons {
      display: flex;
      gap: 10px;
      justify-content: center;
      margin-top: 10px;
    }
    .reward-buttons .btn {
      flex: 1;
      max-width: 140px;
    }
  </style>
</head>
<body>
  <div class="header">
    <div class="title">ç¯ç¬¼å¶å­æ¶ˆæ¶ˆä¹</div>
    <div class="hud">
      <div class="hud-item">
        <div class="hud-label">å…³å¡</div>
        <div class="hud-value" id="levelNum">1</div>
      </div>
      <div class="goal-box" id="goalText">æ”¶é›† 8 ä¸ªå¶å­</div>
      <div class="hud-item">
        <div class="hud-label">æ­¥æ•°</div>
        <div class="hud-value" id="movesLeft">15</div>
      </div>
      <div class="hud-item energy-bar">
        <span class="energy-icon">âš¡</span>
        <div>
          <div class="hud-value" id="energy">5/5</div>
          <div class="energy-timer" id="energyTimer">å·²æ»¡</div>
        </div>
      </div>
    </div>
    <div class="newbie-hint" id="newbieHint" style="display:none;">
      ğŸ æ–°æ‰‹ä¿æŠ¤æœŸï¼šå‰10å…³ä¸æ¶ˆè€—ä½“åŠ›
    </div>
  </div>

  <canvas id="gameCanvas" width="540" height="540"></canvas>

  <!-- é“å…·æ  -->
  <div class="item-bar" id="itemBar">
    <div class="item-slot" id="item-hint" data-item="hint" title="æç¤º">
      <span class="item-icon">ğŸ’¡</span>
      <span class="item-count" id="count-hint">3</span>
      <div class="item-cooldown" id="cooldown-hint"></div>
    </div>
    <div class="item-slot" id="item-shuffle" data-item="shuffle" title="é‡æ’">
      <span class="item-icon">ğŸ”€</span>
      <span class="item-count" id="count-shuffle">2</span>
      <div class="item-cooldown" id="cooldown-shuffle"></div>
    </div>
    <div class="item-slot" id="item-hammer" data-item="hammer" title="é”¤å­">
      <span class="item-icon">ğŸ”¨</span>
      <span class="item-count" id="count-hammer">1</span>
      <div class="item-cooldown" id="cooldown-hammer"></div>
    </div>
    <div class="item-slot locked" id="item-row_clear" data-item="row_clear" title="æ¸…è¡Œ (15æ˜Ÿè§£é”)">
      <span class="item-icon">â¡ï¸</span>
      <span class="item-count" id="count-row_clear">0</span>
      <span class="item-lock">ğŸ”’</span>
      <div class="item-cooldown" id="cooldown-row_clear"></div>
    </div>
    <div class="item-slot locked" id="item-col_clear" data-item="col_clear" title="æ¸…åˆ— (30æ˜Ÿè§£é”)">
      <span class="item-icon">â¬‡ï¸</span>
      <span class="item-count" id="count-col_clear">0</span>
      <span class="item-lock">ğŸ”’</span>
      <div class="item-cooldown" id="cooldown-col_clear"></div>
    </div>
    <div class="item-slot locked" id="item-bomb" data-item="bomb" title="ç‚¸å¼¹ (50æ˜Ÿè§£é”)">
      <span class="item-icon">ğŸ’£</span>
      <span class="item-count" id="count-bomb">0</span>
      <span class="item-lock">ğŸ”’</span>
      <div class="item-cooldown" id="cooldown-bomb"></div>
    </div>
  </div>

  <div class="controls">
    <button class="btn btn-secondary" id="backBtn">è¿”å›</button>
    <button class="btn btn-primary" id="restartBtn">é‡æ–°å¼€å§‹</button>
  </div>

  <div class="message" id="messageBox">
    <h2 id="msgTitle">æ­å–œé€šå…³!</h2>
    <p id="msgContent">å‰©ä½™ 5 æ­¥</p>
    <div class="message-buttons">
      <button class="btn btn-ad" id="msgAdBtn" style="display:none;">ğŸ¬ çœ‹å¹¿å‘Š +3æ­¥</button>
      <button class="btn btn-primary" id="msgBtn">ç»§ç»­</button>
    </div>
  </div>

  <div class="combo-text" id="comboText">è¿æ¶ˆ x2!</div>

  <!-- å¥–åŠ±å¼¹çª— -->
  <div class="reward-popup" id="rewardPopup">
    <h3 id="rewardTitle">ğŸ é€šå…³å¥–åŠ±</h3>
    <div class="reward-items" id="rewardItems"></div>
    <div class="reward-buttons">
      <button class="btn btn-ad" id="doubleRewardBtn">ğŸ¬ åŒå€å¥–åŠ±</button>
      <button class="btn btn-primary" id="rewardCloseBtn">é¢†å–</button>
    </div>
  </div>

  <!-- ä½“åŠ›ä¸è¶³å¼¹çª— -->
  <div class="energy-gate" id="energyGate" style="display:none;">
    <div class="energy-gate-content">
      <div class="big-icon">âš¡</div>
      <h2>ä½“åŠ›ä¸è¶³</h2>
      <p>å½“å‰ä½“åŠ›: <span id="gateEnergyCurrent">0</span>/<span id="gateEnergyMax">5</span></p>
      <p>ä¸‹æ¬¡æ¢å¤: <span id="gateEnergyTimer">--:--</span></p>
      <button class="btn btn-ad" id="watchAdBtn">ğŸ¬ çœ‹å¹¿å‘Š +1ä½“åŠ›</button>
      <div class="ad-remaining">ä»Šæ—¥å‰©ä½™: <span id="adRemaining">6</span> æ¬¡</div>
      <button class="btn btn-secondary" id="waitBtn">ç­‰å¾…æ¢å¤</button>
    </div>
  </div>

<script>
// ============================================
// ç¯ç¬¼å¶å­æ¶ˆæ¶ˆä¹ - Web Demo
// ============================================

// --- ç±»å‹å¸¸é‡ ---
const TILE_TYPES = ['leaf', 'acorn', 'star', 'fish', 'bone'];
const TILE_COLORS = {
  leaf: '#4CAF50',
  acorn: '#8B4513',
  star: '#FFD700',
  fish: '#2196F3',
  bone: '#F5F5DC'
};
const TILE_EMOJIS = {
  leaf: 'ğŸƒ',
  acorn: 'ğŸŒ°',
  star: 'â­',
  fish: 'ğŸŸ',
  bone: 'ğŸ¦´'
};
const SPECIAL_COLORS = {
  whirl_h: '#FF5722',
  whirl_v: '#FF5722',
  lantern: '#E91E63',
  rainbow: 'linear-gradient(135deg, #FF0000, #FF7F00, #FFFF00, #00FF00, #0000FF, #4B0082, #9400D3)',
  wildcard: '#9C27B0',
  multiplier: '#FFEB3B',
  frozen: '#00BCD4',
  bomb_timer: '#F44336'
};

const SPECIAL_ICONS = {
  whirl_h: 'â†”',
  whirl_v: 'â†•',
  lantern: 'ğŸ’¥',
  rainbow: 'ğŸŒˆ',
  wildcard: 'ğŸƒ',
  multiplier: 'Ã—2',
  frozen: 'â„ï¸',
  bomb_timer: 'ğŸ’£'
};

// ç‰¹æ®Šå—ç”Ÿæˆé…ç½®
const SPECIAL_GENERATION = {
  multiplier: { probability: 0.02, minLevel: 11 },
  wildcard: { probability: 0.01, minLevel: 21 },
  frozen: { probability: 0.015, minLevel: 16 },
  bomb_timer: { probability: 0.005, minLevel: 31 }
};

// è¿æ¶ˆå¥–åŠ±é…ç½®
const COMBO_REWARDS = {
  3: { type: 'multiplier', quantity: 1 },  // 3è¿æ¶ˆç”Ÿæˆå€æ•°å—
  4: { type: 'wildcard', quantity: 1 },    // 4è¿æ¶ˆç”Ÿæˆç™¾æ­å—
  5: { type: 'rainbow', quantity: 1 }      // 5è¿æ¶ˆ+ç”Ÿæˆå½©è™¹å—
};

// è¿æ¶ˆè§†è§‰æ•ˆæœé…ç½®
const COMBO_STYLES = {
  2: { size: 'normal', color: '#FFFFFF', animation: 'fadeIn' },
  3: { size: 'large', color: '#FFFF00', animation: 'pulse' },
  4: { size: 'larger', color: '#FFA500', animation: 'shake' },
  5: { size: 'largest', color: '#FF0000', animation: 'flash' }
};

// è¿æ¶ˆç»Ÿè®¡
let comboStats = {
  sessionMax: 0,
  allTimeMax: 0
};

function loadComboStats() {
  try {
    const saved = localStorage.getItem('lanternleaf_combo_stats');
    if (saved) {
      comboStats = JSON.parse(saved);
    }
  } catch (e) {
    console.log('Failed to load combo stats:', e);
  }
}

function saveComboStats() {
  try {
    localStorage.setItem('lanternleaf_combo_stats', JSON.stringify(comboStats));
  } catch (e) {
    console.log('Failed to save combo stats:', e);
  }
}

// ==================== å¹¿å‘Šç³»ç»Ÿ ====================
const AD_CONFIG = {
  energy: { hourlyLimit: 6, reward: 1 },
  extraMoves: { perLevelLimit: 1, reward: 3 },
  hintAd: { dailyLimit: 3, reward: 2 },
  shuffleAd: { dailyLimit: 3, reward: 1 },
  doubleReward: { unlimited: true }
};

let adState = {
  // ä½“åŠ›å¹¿å‘Šï¼ˆæ¯å°æ—¶é‡ç½®ï¼‰
  energyAdCount: 0,
  energyAdHourStart: 0,
  // ç»­å‘½å¹¿å‘Šï¼ˆæ¯å…³é‡ç½®ï¼‰
  usedContinueThisLevel: false,
  // é“å…·å¹¿å‘Šï¼ˆæ¯æ—¥é‡ç½®ï¼‰
  hintAdCount: 0,
  shuffleAdCount: 0,
  dailyResetTime: 0
};

function loadAdState() {
  try {
    const saved = localStorage.getItem('lanternleaf_ad_state');
    if (saved) {
      const data = JSON.parse(saved);
      adState = { ...adState, ...data };

      const now = Date.now();

      // æ£€æŸ¥æ¯å°æ—¶é‡ç½®
      if (now - adState.energyAdHourStart > 3600000) {
        adState.energyAdCount = 0;
        adState.energyAdHourStart = now;
      }

      // æ£€æŸ¥æ¯æ—¥é‡ç½®
      const today = new Date().setHours(0, 0, 0, 0);
      if (adState.dailyResetTime < today) {
        adState.hintAdCount = 0;
        adState.shuffleAdCount = 0;
        adState.dailyResetTime = today;
      }
    }
  } catch (e) {
    console.log('Failed to load ad state:', e);
  }
}

function saveAdState() {
  try {
    localStorage.setItem('lanternleaf_ad_state', JSON.stringify(adState));
  } catch (e) {
    console.log('Failed to save ad state:', e);
  }
}

function resetLevelAdState() {
  adState.usedContinueThisLevel = false;
}

// ç»­å‘½å¹¿å‘Š
function canUseContinueAd() {
  return !adState.usedContinueThisLevel;
}

function watchContinueAd(callback) {
  if (!canUseContinueAd()) {
    showMessage('æç¤º', 'æœ¬å…³å·²ä½¿ç”¨è¿‡ç»­å‘½', () => {});
    setTimeout(hideMessage, 1200);
    return;
  }

  // æ¨¡æ‹Ÿå¹¿å‘Š
  showMessage('è§‚çœ‹å¹¿å‘Š', 'æ¨¡æ‹Ÿå¹¿å‘Šæ’­æ”¾ä¸­...', null);
  document.getElementById('msgAdBtn').style.display = 'none';

  setTimeout(() => {
    adState.usedContinueThisLevel = true;
    saveAdState();
    hideMessage();

    // ç»™äºˆé¢å¤–æ­¥æ•°
    gameState.moves += AD_CONFIG.extraMoves.reward;
    gameState.isFailed = false;
    updateHUD();
    render();

    showMessage('è·å¾—ç»­å‘½', `+${AD_CONFIG.extraMoves.reward} æ­¥ï¼Œç»§ç»­æŒ‘æˆ˜!`, () => {});
    setTimeout(hideMessage, 1000);

    if (callback) callback();
  }, 1500);
}

// é“å…·å¹¿å‘Š
function canWatchHintAd() {
  const today = new Date().setHours(0, 0, 0, 0);
  if (adState.dailyResetTime < today) {
    adState.hintAdCount = 0;
    adState.shuffleAdCount = 0;
    adState.dailyResetTime = today;
  }
  return adState.hintAdCount < AD_CONFIG.hintAd.dailyLimit;
}

function canWatchShuffleAd() {
  const today = new Date().setHours(0, 0, 0, 0);
  if (adState.dailyResetTime < today) {
    adState.hintAdCount = 0;
    adState.shuffleAdCount = 0;
    adState.dailyResetTime = today;
  }
  return adState.shuffleAdCount < AD_CONFIG.shuffleAd.dailyLimit;
}

function watchHintAd() {
  if (!canWatchHintAd()) {
    showMessage('æç¤º', 'ä»Šæ—¥æ¬¡æ•°å·²ç”¨å®Œ', () => {});
    setTimeout(hideMessage, 1200);
    return;
  }

  showMessage('è§‚çœ‹å¹¿å‘Š', 'æ¨¡æ‹Ÿå¹¿å‘Šæ’­æ”¾ä¸­...', null);
  setTimeout(() => {
    adState.hintAdCount++;
    saveAdState();
    addItem('hint', AD_CONFIG.hintAd.reward);
    hideMessage();
    showMessage('è·å¾—é“å…·', `+${AD_CONFIG.hintAd.reward} æç¤º`, () => {});
    setTimeout(hideMessage, 1000);
  }, 1500);
}

function watchShuffleAd() {
  if (!canWatchShuffleAd()) {
    showMessage('æç¤º', 'ä»Šæ—¥æ¬¡æ•°å·²ç”¨å®Œ', () => {});
    setTimeout(hideMessage, 1200);
    return;
  }

  showMessage('è§‚çœ‹å¹¿å‘Š', 'æ¨¡æ‹Ÿå¹¿å‘Šæ’­æ”¾ä¸­...', null);
  setTimeout(() => {
    adState.shuffleAdCount++;
    saveAdState();
    addItem('shuffle', AD_CONFIG.shuffleAd.reward);
    hideMessage();
    showMessage('è·å¾—é“å…·', `+${AD_CONFIG.shuffleAd.reward} é‡æ’`, () => {});
    setTimeout(hideMessage, 1000);
  }, 1500);
}

const BOARD_SIZE = 6;
const CELL_SIZE = 80;
const CELL_GAP = 10;
const PADDING = 10;  // æ£‹ç›˜è¾¹è·

// --- RNG (Mulberry32) ---
class RNG {
  constructor(seed) {
    this.state = seed >>> 0;
  }
  random() {
    let t = (this.state += 0x6d2b79f5);
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  }
  randInt(min, max) {
    return Math.floor(this.random() * (max - min + 1)) + min;
  }
  sample(array, k) {
    const result = [];
    const indices = new Set();
    const n = array.length;
    while (result.length < k && result.length < n) {
      const idx = this.randInt(0, n - 1);
      if (!indices.has(idx)) {
        indices.add(idx);
        result.push(array[idx]);
      }
    }
    return result;
  }
  shuffle(array) {
    const result = [...array];
    for (let i = result.length - 1; i > 0; i--) {
      const j = this.randInt(0, i);
      [result[i], result[j]] = [result[j], result[i]];
    }
    return result;
  }
  weightedChoice(items, weights) {
    const total = weights.reduce((a, b) => a + b, 0);
    let r = this.random() * total;
    for (let i = 0; i < items.length; i++) {
      r -= weights[i];
      if (r <= 0) return items[i];
    }
    return items[items.length - 1];
  }
}

// --- è‹”è—“æ¨¡å¼ ---
const MOSS_PATTERNS = {
  none: [],
  edge_ring: (() => {
    const cells = [];
    for (let c = 0; c < 6; c++) { cells.push({row: 0, col: c}); cells.push({row: 5, col: c}); }
    for (let r = 1; r < 5; r++) { cells.push({row: r, col: 0}); cells.push({row: r, col: 5}); }
    return cells;
  })(),
  corners: [
    {row:0,col:0},{row:0,col:1},{row:1,col:0},{row:1,col:1},
    {row:0,col:4},{row:0,col:5},{row:1,col:4},{row:1,col:5},
    {row:4,col:0},{row:4,col:1},{row:5,col:0},{row:5,col:1},
    {row:4,col:4},{row:4,col:5},{row:5,col:4},{row:5,col:5}
  ],
  center_blob: [
    {row:2,col:2},{row:2,col:3},{row:3,col:2},{row:3,col:3},
    {row:1,col:2},{row:1,col:3},{row:4,col:2},{row:4,col:3},
    {row:2,col:1},{row:3,col:1},{row:2,col:4},{row:3,col:4}
  ],
  diagonal: [
    {row:0,col:0},{row:1,col:1},{row:2,col:2},{row:3,col:3},{row:4,col:4},{row:5,col:5},
    {row:0,col:1},{row:1,col:2},{row:2,col:3},{row:3,col:4},{row:4,col:5}
  ]
};

// --- åŸºç¡€å…³å¡é…ç½® (å‰50å…³æ‰‹å·¥è®¾è®¡) ---
const BASE_LEVELS = [
  // ç¬¬1-10å…³ï¼šæ–°æ‰‹æœŸï¼ˆä¸æ‰£ä½“åŠ›ï¼‰
  { level: 1,  moves: 15, goal: 'collect', item: 'leaf',  count: 8,  pattern: 'none', density: 0 },
  { level: 2,  moves: 15, goal: 'collect', item: 'acorn', count: 8,  pattern: 'none', density: 0 },
  { level: 3,  moves: 14, goal: 'collect', item: 'star',  count: 10, pattern: 'none', density: 0 },
  { level: 4,  moves: 14, goal: 'collect', item: 'fish',  count: 10, pattern: 'none', density: 0 },
  { level: 5,  moves: 14, goal: 'collect', item: 'bone',  count: 10, pattern: 'corners', density: 0.2 },
  { level: 6,  moves: 13, goal: 'clear_moss', count: 4,   pattern: 'corners', density: 0.3 },
  { level: 7,  moves: 13, goal: 'collect', item: 'leaf',  count: 12, pattern: 'corners', density: 0.25 },
  { level: 8,  moves: 13, goal: 'clear_moss', count: 5,   pattern: 'edge_ring', density: 0.3 },
  { level: 9,  moves: 12, goal: 'collect', item: 'acorn', count: 12, pattern: 'edge_ring', density: 0.3 },
  { level: 10, moves: 12, goal: 'clear_moss', count: 6,   pattern: 'center_blob', density: 0.35 },

  // ç¬¬11-20å…³ï¼šå…¥é—¨æœŸ
  { level: 11, moves: 12, goal: 'collect', item: 'star',  count: 14, pattern: 'center_blob', density: 0.3 },
  { level: 12, moves: 12, goal: 'clear_moss', count: 7,   pattern: 'diagonal', density: 0.4 },
  { level: 13, moves: 11, goal: 'collect', item: 'fish',  count: 14, pattern: 'diagonal', density: 0.35 },
  { level: 14, moves: 11, goal: 'clear_moss', count: 8,   pattern: 'corners', density: 0.5 },
  { level: 15, moves: 11, goal: 'collect', item: 'bone',  count: 15, pattern: 'edge_ring', density: 0.4 },
  { level: 16, moves: 11, goal: 'clear_moss', count: 9,   pattern: 'center_blob', density: 0.5 },
  { level: 17, moves: 10, goal: 'collect', item: 'leaf',  count: 16, pattern: 'center_blob', density: 0.45 },
  { level: 18, moves: 10, goal: 'clear_moss', count: 10,  pattern: 'diagonal', density: 0.55 },
  { level: 19, moves: 10, goal: 'collect', item: 'acorn', count: 16, pattern: 'edge_ring', density: 0.5 },
  { level: 20, moves: 10, goal: 'clear_moss', count: 10,  pattern: 'corners', density: 0.6 },

  // ç¬¬21-30å…³ï¼šè¿›é˜¶æœŸ
  { level: 21, moves: 10, goal: 'collect', item: 'star',  count: 18, pattern: 'center_blob', density: 0.5 },
  { level: 22, moves: 10, goal: 'clear_moss', count: 11,  pattern: 'diagonal', density: 0.6 },
  { level: 23, moves: 9,  goal: 'collect', item: 'fish',  count: 16, pattern: 'edge_ring', density: 0.55 },
  { level: 24, moves: 9,  goal: 'clear_moss', count: 11,  pattern: 'center_blob', density: 0.65 },
  { level: 25, moves: 9,  goal: 'collect', item: 'bone',  count: 18, pattern: 'diagonal', density: 0.55 },
  { level: 26, moves: 9,  goal: 'clear_moss', count: 12,  pattern: 'corners', density: 0.7 },
  { level: 27, moves: 9,  goal: 'collect', item: 'leaf',  count: 20, pattern: 'center_blob', density: 0.6 },
  { level: 28, moves: 8,  goal: 'clear_moss', count: 12,  pattern: 'edge_ring', density: 0.7 },
  { level: 29, moves: 8,  goal: 'collect', item: 'acorn', count: 18, pattern: 'diagonal', density: 0.65 },
  { level: 30, moves: 8,  goal: 'clear_moss', count: 13,  pattern: 'center_blob', density: 0.75 },

  // ç¬¬31-40å…³ï¼šæŒ‘æˆ˜æœŸ
  { level: 31, moves: 8,  goal: 'collect', item: 'star',  count: 20, pattern: 'edge_ring', density: 0.65 },
  { level: 32, moves: 8,  goal: 'clear_moss', count: 13,  pattern: 'diagonal', density: 0.75 },
  { level: 33, moves: 8,  goal: 'collect', item: 'fish',  count: 20, pattern: 'center_blob', density: 0.7 },
  { level: 34, moves: 8,  goal: 'clear_moss', count: 14,  pattern: 'corners', density: 0.8 },
  { level: 35, moves: 7,  goal: 'collect', item: 'bone',  count: 18, pattern: 'diagonal', density: 0.7 },
  { level: 36, moves: 7,  goal: 'clear_moss', count: 14,  pattern: 'edge_ring', density: 0.8 },
  { level: 37, moves: 7,  goal: 'collect', item: 'leaf',  count: 22, pattern: 'center_blob', density: 0.75 },
  { level: 38, moves: 7,  goal: 'clear_moss', count: 15,  pattern: 'diagonal', density: 0.85 },
  { level: 39, moves: 7,  goal: 'collect', item: 'acorn', count: 22, pattern: 'edge_ring', density: 0.75 },
  { level: 40, moves: 7,  goal: 'clear_moss', count: 15,  pattern: 'center_blob', density: 0.85 },

  // ç¬¬41-50å…³ï¼šå¤§å¸ˆæœŸ
  { level: 41, moves: 7,  goal: 'collect', item: 'star',  count: 24, pattern: 'diagonal', density: 0.8 },
  { level: 42, moves: 6,  goal: 'clear_moss', count: 14,  pattern: 'corners', density: 0.9 },
  { level: 43, moves: 6,  goal: 'collect', item: 'fish',  count: 22, pattern: 'center_blob', density: 0.85 },
  { level: 44, moves: 6,  goal: 'clear_moss', count: 15,  pattern: 'edge_ring', density: 0.9 },
  { level: 45, moves: 6,  goal: 'collect', item: 'bone',  count: 24, pattern: 'diagonal', density: 0.85 },
  { level: 46, moves: 6,  goal: 'clear_moss', count: 16,  pattern: 'center_blob', density: 0.95 },
  { level: 47, moves: 6,  goal: 'collect', item: 'leaf',  count: 26, pattern: 'edge_ring', density: 0.9 },
  { level: 48, moves: 5,  goal: 'clear_moss', count: 15,  pattern: 'diagonal', density: 0.95 },
  { level: 49, moves: 5,  goal: 'collect', item: 'acorn', count: 24, pattern: 'center_blob', density: 0.9 },
  { level: 50, moves: 5,  goal: 'clear_moss', count: 16,  pattern: 'edge_ring', density: 1.0 }
];

// --- æ— é™å…³å¡ç”Ÿæˆå™¨ ---
const PATTERN_POOL = ['corners', 'edge_ring', 'center_blob', 'diagonal'];

function generateInfiniteLevel(levelIndex) {
  // ä½¿ç”¨å…³å¡å·ä½œä¸ºç§å­ï¼Œä¿è¯æ¯æ¬¡ç”Ÿæˆç›¸åŒçš„å…³å¡
  const seed = levelIndex * 31337;
  const rng = new RNG(seed);

  // è®¡ç®—éš¾åº¦ç³»æ•° (50å…³åé€æ¸å¢åŠ ï¼Œæœ€ç»ˆè¶‹äºç¨³å®š)
  const difficultyOffset = levelIndex - 50;
  const difficultyFactor = Math.min(1 + difficultyOffset * 0.02, 2.0); // æœ€é«˜2å€éš¾åº¦

  // æ³¢åŠ¨å‘¨æœŸï¼šæ¯10å…³ä¸€ä¸ªå°å‘¨æœŸï¼Œæœ‰æ—¶ç®€å•æœ‰æ—¶éš¾
  const waveFactor = 0.8 + 0.4 * Math.sin(levelIndex * 0.3);

  // æ­¥æ•°ï¼šåŸºç¡€5æ­¥ï¼Œæ ¹æ®éš¾åº¦å’Œæ³¢åŠ¨è°ƒæ•´ (4-8æ­¥)
  const baseMovesVariation = rng.randInt(-1, 2);
  const moves = Math.max(4, Math.min(8, 5 + baseMovesVariation + Math.floor((1 - waveFactor) * 2)));

  // ç›®æ ‡ç±»å‹ï¼šäº¤æ›¿æ”¶é›†å’Œæ¸…è‹”è—“ï¼Œå¶å°”å‡ºcombo
  let goal, item, count;
  const goalRoll = rng.random();
  if (goalRoll < 0.5) {
    goal = 'collect';
    item = TILE_TYPES[rng.randInt(0, TILE_TYPES.length - 1)];
    // æ”¶é›†æ•°é‡ï¼šåŸºç¡€20ï¼Œæ ¹æ®éš¾åº¦å¢åŠ 
    count = Math.floor(20 + difficultyOffset * 0.3 * waveFactor);
    count = Math.min(count, 35); // ä¸Šé™35
  } else {
    goal = 'clear_moss';
    item = null;
    // è‹”è—“æ•°é‡ç”± density æ§åˆ¶ï¼Œè¿™é‡Œ count ç”¨äºè®°å½•ç›®æ ‡
    count = 0; // clear_moss æ¨¡å¼ä¸‹æ¸…é™¤æ‰€æœ‰è‹”è—“
  }

  // è‹”è—“ pattern éšæœºé€‰æ‹©
  const pattern = PATTERN_POOL[rng.randInt(0, PATTERN_POOL.length - 1)];

  // è‹”è—“å¯†åº¦ï¼šåŸºç¡€0.6ï¼Œæ ¹æ®éš¾åº¦å¢åŠ ï¼Œæœ‰æ³¢åŠ¨
  let density = 0.6 + difficultyOffset * 0.01 * waveFactor;
  density = Math.min(density, 0.95); // ä¸Šé™95%

  // ç‰¹æ®Šå…³å¡æ ‡è®°ï¼ˆæ¯25å…³ä¸€ä¸ªbosså…³ï¼‰
  const isBossLevel = levelIndex % 25 === 0;
  if (isBossLevel) {
    // Bosså…³ï¼šæ›´éš¾
    count = goal === 'collect' ? Math.min(count + 5, 35) : count;
    density = Math.min(density + 0.1, 0.98);
  }

  return {
    level: levelIndex,
    moves,
    goal,
    item,
    count,
    pattern,
    density,
    isBossLevel
  };
}

// è·å–å…³å¡é…ç½®ï¼ˆæ”¯æŒæ— é™å…³å¡ï¼‰
function getLevelConfig(levelIndex) {
  if (levelIndex <= BASE_LEVELS.length) {
    return BASE_LEVELS[levelIndex - 1];
  }
  return generateInfiniteLevel(levelIndex);
}

// å…¼å®¹æ—§ä»£ç çš„ LEVELS æ•°ç»„è®¿é—®
const LEVELS = new Proxy(BASE_LEVELS, {
  get(target, prop) {
    if (prop === 'length') return Infinity;
    const index = parseInt(prop);
    if (!isNaN(index)) {
      return getLevelConfig(index + 1);
    }
    return target[prop];
  }
});

// --- ä½“åŠ›ç³»ç»Ÿé…ç½® ---
const ENERGY_CONFIG = {
  max: 5,
  regenSeconds: 20 * 60,  // 20åˆ†é’Ÿæ¢å¤1ç‚¹
  adReward: 1,
  adHourlyCap: 6,
  newbieProtection: 10    // å‰10å…³ä¸æ‰£ä½“åŠ›
};

// --- é“å…·ç³»ç»Ÿé…ç½® ---
const ITEM_CONFIG = {
  types: ['hint', 'shuffle', 'hammer', 'row_clear', 'col_clear', 'bomb'],
  icons: {
    hint: 'ğŸ’¡', shuffle: 'ğŸ”€', hammer: 'ğŸ”¨',
    row_clear: 'â¡ï¸', col_clear: 'â¬‡ï¸', bomb: 'ğŸ’£'
  },
  names: {
    hint: 'æç¤º', shuffle: 'é‡æ’', hammer: 'é”¤å­',
    row_clear: 'æ¸…è¡Œ', col_clear: 'æ¸…åˆ—', bomb: 'ç‚¸å¼¹'
  },
  // æ¯å…³ä½¿ç”¨æ¬¡æ•°é™åˆ¶ (-1 = æ— é™åˆ¶)
  perLevelLimit: {
    hint: -1, shuffle: 2, hammer: 3,
    row_clear: 1, col_clear: 1, bomb: 1
  },
  // å†·å´æ—¶é—´ (æ¯«ç§’)
  cooldown: {
    hint: 3000, shuffle: 5000, hammer: 0,
    row_clear: 0, col_clear: 0, bomb: 0
  },
  // è§£é”æ˜Ÿæ•°è¦æ±‚
  unlockStars: {
    hint: 0, shuffle: 0, hammer: 0,
    row_clear: 15, col_clear: 30, bomb: 50
  },
  // é»˜è®¤åº“å­˜
  defaultInventory: {
    hint: 3, shuffle: 2, hammer: 1,
    row_clear: 0, col_clear: 0, bomb: 0
  }
};

// é€šå…³å¥–åŠ±é…ç½®
const REWARD_CONFIG = {
  levelClear: { hint: 1 },           // é€šå…³å¥–åŠ±
  threeStarClear: { shuffle: 1 },    // 3æ˜Ÿé¢å¤–å¥–åŠ±
  bossLevelClear: { hammer: 1 }      // Bosså…³é¢å¤–å¥–åŠ±
};

// æ˜Ÿçº§é‡Œç¨‹ç¢‘å¥–åŠ±
const STAR_MILESTONES = [
  { stars: 15, rewards: { row_clear: 1 }, unlocks: ['row_clear'] },
  { stars: 30, rewards: { col_clear: 1 }, unlocks: ['col_clear'] },
  { stars: 50, rewards: { bomb: 1 }, unlocks: ['bomb'] },
  { stars: 75, rewards: { hint: 3, shuffle: 2 } },
  { stars: 100, rewards: { hammer: 2, bomb: 1 } },
  { stars: 150, rewards: { hint: 2, shuffle: 2, hammer: 2, row_clear: 2, col_clear: 2, bomb: 2 } }
];

// --- æ¸¸æˆçŠ¶æ€ ---
let gameState = {
  board: [],
  level: 1,
  moves: 15,
  goal: null,
  goalProgress: 0,
  energy: {
    current: 5,
    max: 5,
    lastRegenTime: Date.now(),
    adWatchedThisHour: 0,
    adHourStart: Date.now()
  },
  // é“å…·ç³»ç»Ÿ
  inventory: { ...ITEM_CONFIG.defaultInventory },
  itemLevelState: {
    usageCount: { hint: 0, shuffle: 0, hammer: 0, row_clear: 0, col_clear: 0, bomb: 0 },
    lastUsedTime: { hint: 0, shuffle: 0, hammer: 0, row_clear: 0, col_clear: 0, bomb: 0 }
  },
  claimedMilestones: [],  // å·²é¢†å–çš„é‡Œç¨‹ç¢‘æ˜Ÿæ•°
  activeItem: null,       // å½“å‰æ¿€æ´»çš„é“å…·ï¼ˆç­‰å¾…é€‰æ‹©ç›®æ ‡ï¼‰
  selectedCell: null,
  isAnimating: false,
  rng: null
};

// --- ä½“åŠ›ç³»ç»Ÿå‡½æ•° ---
function loadEnergyState() {
  try {
    const saved = localStorage.getItem('lanternleaf_energy');
    if (saved) {
      const data = JSON.parse(saved);
      gameState.energy.current = data.current;
      gameState.energy.lastRegenTime = data.lastRegenTime;
      gameState.energy.adWatchedThisHour = data.adWatchedThisHour || 0;
      gameState.energy.adHourStart = data.adHourStart || Date.now();

      // è®¡ç®—ç¦»çº¿æœŸé—´æ¢å¤çš„ä½“åŠ›
      const now = Date.now();
      const elapsed = now - gameState.energy.lastRegenTime;
      const regenPoints = Math.floor(elapsed / (ENERGY_CONFIG.regenSeconds * 1000));
      if (regenPoints > 0) {
        gameState.energy.current = Math.min(
          gameState.energy.max,
          gameState.energy.current + regenPoints
        );
        gameState.energy.lastRegenTime = now;
      }

      // é‡ç½®æ¯å°æ—¶å¹¿å‘Šè®¡æ•°
      if (now - gameState.energy.adHourStart > 3600000) {
        gameState.energy.adWatchedThisHour = 0;
        gameState.energy.adHourStart = now;
      }
    }
    // åŒæ—¶åŠ è½½å…³å¡è¿›åº¦
    const levelSaved = localStorage.getItem('lanternleaf_level');
    if (levelSaved) {
      gameState.level = parseInt(levelSaved) || 1;
    }
  } catch (e) {
    console.log('Failed to load energy state:', e);
  }
}

function saveEnergyState() {
  try {
    localStorage.setItem('lanternleaf_energy', JSON.stringify({
      current: gameState.energy.current,
      lastRegenTime: gameState.energy.lastRegenTime,
      adWatchedThisHour: gameState.energy.adWatchedThisHour,
      adHourStart: gameState.energy.adHourStart
    }));
    localStorage.setItem('lanternleaf_level', gameState.level.toString());
  } catch (e) {
    console.log('Failed to save energy state:', e);
  }
}

// ç©å®¶è¿›åº¦å­˜å‚¨ï¼ˆä¸ PlayerProgress.ts æ ¼å¼ä¸€è‡´ï¼‰
let playerProgress = {
  currentLevel: 1,
  levelStars: {},
  totalStars: 0,
  completedLevels: 0,
  lastPlayTime: Date.now(),
  version: 1
};

function loadPlayerProgress() {
  try {
    const saved = localStorage.getItem('lanternleaf_player_progress');
    if (saved) {
      const data = JSON.parse(saved);
      playerProgress = { ...playerProgress, ...data };
    }
  } catch (e) {
    console.log('Failed to load player progress:', e);
  }
}

function savePlayerProgress() {
  try {
    playerProgress.lastPlayTime = Date.now();
    localStorage.setItem('lanternleaf_player_progress', JSON.stringify(playerProgress));
  } catch (e) {
    console.log('Failed to save player progress:', e);
  }
}

function completeLevel(level, stars) {
  // æ›´æ–°æ˜Ÿçº§ï¼ˆåªä¿å­˜æ›´é«˜æ˜Ÿçº§ï¼‰
  const currentStars = playerProgress.levelStars[level] || 0;
  if (stars > currentStars) {
    playerProgress.totalStars += (stars - currentStars);
    playerProgress.levelStars[level] = stars;
  }

  // æ›´æ–°å·²é€šå…³æ•°
  if (!playerProgress.levelStars[level] || currentStars === 0) {
    playerProgress.completedLevels++;
  }

  // è§£é”ä¸‹ä¸€å…³
  if (level >= playerProgress.currentLevel && level < 50) {
    playerProgress.currentLevel = level + 1;
  }

  savePlayerProgress();
}

// ==================== é“å…·ç³»ç»Ÿå‡½æ•° ====================

const INVENTORY_STORAGE_KEY = 'lanternleaf_inventory';
const MILESTONES_STORAGE_KEY = 'lanternleaf_claimed_milestones';

function loadInventory() {
  try {
    const saved = localStorage.getItem(INVENTORY_STORAGE_KEY);
    if (saved) {
      const data = JSON.parse(saved);
      gameState.inventory = { ...ITEM_CONFIG.defaultInventory, ...data };
    }
    const milestones = localStorage.getItem(MILESTONES_STORAGE_KEY);
    if (milestones) {
      gameState.claimedMilestones = JSON.parse(milestones);
    }
  } catch (e) {
    console.log('Failed to load inventory:', e);
  }
}

function saveInventory() {
  try {
    localStorage.setItem(INVENTORY_STORAGE_KEY, JSON.stringify(gameState.inventory));
    localStorage.setItem(MILESTONES_STORAGE_KEY, JSON.stringify(gameState.claimedMilestones));
  } catch (e) {
    console.log('Failed to save inventory:', e);
  }
}

function resetLevelItemState() {
  gameState.itemLevelState = {
    usageCount: { hint: 0, shuffle: 0, hammer: 0, row_clear: 0, col_clear: 0, bomb: 0 },
    lastUsedTime: { hint: 0, shuffle: 0, hammer: 0, row_clear: 0, col_clear: 0, bomb: 0 }
  };
  gameState.activeItem = null;
}

function isItemUnlocked(itemType) {
  const requirement = ITEM_CONFIG.unlockStars[itemType];
  return playerProgress.totalStars >= requirement;
}

function canUseItem(itemType) {
  // æ£€æŸ¥æ˜¯å¦è§£é”
  if (!isItemUnlocked(itemType)) {
    return { canUse: false, reason: `éœ€è¦ ${ITEM_CONFIG.unlockStars[itemType]} æ˜Ÿè§£é”` };
  }
  // æ£€æŸ¥åº“å­˜
  if (gameState.inventory[itemType] <= 0) {
    return { canUse: false, reason: 'é“å…·æ•°é‡ä¸è¶³' };
  }
  // æ£€æŸ¥æ¯å…³ä½¿ç”¨æ¬¡æ•°
  const limit = ITEM_CONFIG.perLevelLimit[itemType];
  if (limit > 0 && gameState.itemLevelState.usageCount[itemType] >= limit) {
    return { canUse: false, reason: `æœ¬å…³å·²ä½¿ç”¨ ${limit} æ¬¡` };
  }
  // æ£€æŸ¥å†·å´æ—¶é—´
  const cooldown = ITEM_CONFIG.cooldown[itemType];
  if (cooldown > 0) {
    const lastUsed = gameState.itemLevelState.lastUsedTime[itemType] || 0;
    const elapsed = Date.now() - lastUsed;
    if (elapsed < cooldown) {
      const remaining = Math.ceil((cooldown - elapsed) / 1000);
      return { canUse: false, reason: `å†·å´ä¸­ ${remaining}ç§’` };
    }
  }
  return { canUse: true };
}

function consumeItem(itemType) {
  if (gameState.inventory[itemType] <= 0) return false;
  gameState.inventory[itemType]--;
  gameState.itemLevelState.usageCount[itemType]++;
  gameState.itemLevelState.lastUsedTime[itemType] = Date.now();
  saveInventory();
  updateItemBar();
  return true;
}

function addItem(itemType, count = 1) {
  gameState.inventory[itemType] = (gameState.inventory[itemType] || 0) + count;
  saveInventory();
  updateItemBar();
}

function addItems(items) {
  for (const [type, count] of Object.entries(items)) {
    if (count > 0) {
      gameState.inventory[type] = (gameState.inventory[type] || 0) + count;
    }
  }
  saveInventory();
  updateItemBar();
}

// é€šå…³å¥–åŠ±
function grantLevelClearReward(stars, isBossLevel) {
  const rewards = { ...REWARD_CONFIG.levelClear };

  if (stars >= 3) {
    for (const [item, count] of Object.entries(REWARD_CONFIG.threeStarClear)) {
      rewards[item] = (rewards[item] || 0) + count;
    }
  }

  if (isBossLevel) {
    for (const [item, count] of Object.entries(REWARD_CONFIG.bossLevelClear)) {
      rewards[item] = (rewards[item] || 0) + count;
    }
  }

  addItems(rewards);
  return rewards;
}

// æ£€æŸ¥å¹¶å‘æ”¾é‡Œç¨‹ç¢‘å¥–åŠ±
function checkAndGrantMilestoneRewards() {
  const grantedMilestones = [];

  for (const milestone of STAR_MILESTONES) {
    if (playerProgress.totalStars >= milestone.stars &&
        !gameState.claimedMilestones.includes(milestone.stars)) {
      gameState.claimedMilestones.push(milestone.stars);
      addItems(milestone.rewards);
      grantedMilestones.push(milestone);
    }
  }

  if (grantedMilestones.length > 0) {
    saveInventory();
  }

  return grantedMilestones;
}

// å½“å‰å¥–åŠ±ï¼ˆç”¨äºåŒå€å¥–åŠ±ï¼‰
let pendingRewards = null;
let pendingRewardCallback = null;

// æ˜¾ç¤ºå¥–åŠ±å¼¹çª—
function showRewardPopup(title, rewards, onClose = null) {
  const popup = document.getElementById('rewardPopup');
  const titleEl = document.getElementById('rewardTitle');
  const itemsEl = document.getElementById('rewardItems');
  const doubleBtn = document.getElementById('doubleRewardBtn');

  titleEl.textContent = title;
  itemsEl.innerHTML = '';

  // å­˜å‚¨å¾…é¢†å–å¥–åŠ±
  pendingRewards = { ...rewards };
  pendingRewardCallback = onClose;

  // æ˜¾ç¤ºåŒå€å¥–åŠ±æŒ‰é’®
  doubleBtn.style.display = 'inline-block';

  for (const [item, count] of Object.entries(rewards)) {
    if (count > 0) {
      const div = document.createElement('div');
      div.className = 'reward-item';
      div.innerHTML = `
        <span class="icon">${ITEM_CONFIG.icons[item]}</span>
        <span class="amount">+${count}</span>
      `;
      itemsEl.appendChild(div);
    }
  }

  popup.style.display = 'block';
}

function hideRewardPopup() {
  document.getElementById('rewardPopup').style.display = 'none';
  pendingRewards = null;
  pendingRewardCallback = null;
}

// åŒå€å¥–åŠ±
function watchDoubleRewardAd(callback) {
  console.log('[Ad] æ’­æ”¾åŒå€å¥–åŠ±å¹¿å‘Š...');

  // æ¨¡æ‹Ÿå¹¿å‘Šæ’­æ”¾
  setTimeout(() => {
    console.log('[Ad] åŒå€å¥–åŠ±å¹¿å‘Šæ’­æ”¾å®Œæˆ');

    if (pendingRewards) {
      // å‘æ”¾é¢å¤–å¥–åŠ±ï¼ˆåŒå€ = å†å‘ä¸€æ¬¡ï¼‰
      for (const [item, count] of Object.entries(pendingRewards)) {
        if (count > 0) {
          addItem(item, count);
        }
      }
      saveInventory();
      updateItemBar();
    }

    if (callback) callback();
  }, 2500);
}

// æ›´æ–°é“å…·æ  UI
function updateItemBar() {
  for (const itemType of ITEM_CONFIG.types) {
    const slot = document.getElementById(`item-${itemType}`);
    const countEl = document.getElementById(`count-${itemType}`);
    const cooldownEl = document.getElementById(`cooldown-${itemType}`);

    if (!slot) continue;

    // æ›´æ–°æ•°é‡
    countEl.textContent = gameState.inventory[itemType];

    // æ›´æ–°é”å®šçŠ¶æ€
    const unlocked = isItemUnlocked(itemType);
    slot.classList.toggle('locked', !unlocked);
    const lockIcon = slot.querySelector('.item-lock');
    if (lockIcon) {
      lockIcon.style.display = unlocked ? 'none' : 'block';
    }

    // æ›´æ–°ç¦ç”¨çŠ¶æ€
    const { canUse } = canUseItem(itemType);
    slot.classList.toggle('disabled', !canUse && unlocked);

    // æ›´æ–°æ¿€æ´»çŠ¶æ€
    slot.classList.toggle('active', gameState.activeItem === itemType);
  }
}

// å†·å´æ—¶é—´åŠ¨ç”»æ›´æ–°
let cooldownTimer = null;
function startCooldownTimer() {
  if (cooldownTimer) clearInterval(cooldownTimer);
  cooldownTimer = setInterval(() => {
    for (const itemType of ITEM_CONFIG.types) {
      const cooldown = ITEM_CONFIG.cooldown[itemType];
      if (cooldown <= 0) continue;

      const lastUsed = gameState.itemLevelState.lastUsedTime[itemType] || 0;
      const elapsed = Date.now() - lastUsed;
      const remaining = Math.max(0, cooldown - elapsed);

      const cooldownEl = document.getElementById(`cooldown-${itemType}`);
      const slot = document.getElementById(`item-${itemType}`);

      if (remaining > 0) {
        const progress = 1 - (remaining / cooldown);
        cooldownEl.style.transform = `scaleX(${progress})`;
        slot.classList.add('cooldown');
      } else {
        cooldownEl.style.transform = 'scaleX(0)';
        slot.classList.remove('cooldown');
      }
    }
    updateItemBar();
  }, 100);
}

// é“å…·ç‚¹å‡»å¤„ç†
function handleItemClick(itemType) {
  if (gameState.isAnimating) return;

  const { canUse, reason } = canUseItem(itemType);
  if (!canUse) {
    showMessage('æ— æ³•ä½¿ç”¨', reason, () => {});
    setTimeout(hideMessage, 1200);
    return;
  }

  // ç«‹å³ç”Ÿæ•ˆçš„é“å…·
  if (itemType === 'hint') {
    useHintItem();
  } else if (itemType === 'shuffle') {
    useShuffleItem();
  } else {
    // éœ€è¦é€‰æ‹©ç›®æ ‡çš„é“å…·
    if (gameState.activeItem === itemType) {
      gameState.activeItem = null;  // å–æ¶ˆé€‰æ‹©
    } else {
      gameState.activeItem = itemType;
    }
    updateItemBar();
  }
}

// æç¤ºé“å…·
function useHintItem() {
  const move = getValidMove();
  if (!move) {
    showMessage('æç¤º', 'æ²¡æœ‰å¯è¡Œçš„ç§»åŠ¨', () => {});
    setTimeout(hideMessage, 1000);
    return;
  }

  if (!consumeItem('hint')) return;

  // é«˜äº®æç¤º
  gameState.selectedCell = move.from;
  render();
  setTimeout(() => {
    gameState.selectedCell = move.to;
    render();
    setTimeout(() => {
      gameState.selectedCell = null;
      render();
    }, 400);
  }, 400);
}

// é‡æ’é“å…·
function useShuffleItem() {
  if (!consumeItem('shuffle')) return;
  shuffleBoard();
  render();
}

// é”¤å­é“å…·ï¼ˆæ¶ˆé™¤å•ä¸ªæ ¼å­ï¼‰
async function useHammerItem(cell) {
  if (!consumeItem('hammer')) return;
  gameState.activeItem = null;
  updateItemBar();

  gameState.isAnimating = true;

  const boardCell = gameState.board[cell.row][cell.col];

  // å¤„ç†è‹”è—“
  if (boardCell.blocker?.type === 'moss') {
    boardCell.blocker.layer--;
    if (boardCell.blocker.layer <= 0) {
      boardCell.blocker = null;
      if (gameState.goal.type === 'clear_moss') {
        gameState.goalProgress++;
      }
    }
  }

  // æ”¶é›†ç»Ÿè®¡
  if (boardCell.tile && gameState.goal.type === 'collect' && boardCell.tile.type === gameState.goal.item) {
    gameState.goalProgress++;
  }

  // æ¸…é™¤æ ¼å­
  boardCell.tile = null;
  render();
  await sleep(150);

  // ä¸‹è½å¡«å……
  await animateGravity();
  await animateFill();

  // å¤„ç†è¿é”æ¶ˆé™¤
  await resolveMatches();

  updateHUD();
  checkEndCondition();

  gameState.isAnimating = false;
}

// æ¸…è¡Œé“å…·
async function useRowClearItem(cell) {
  if (!consumeItem('row_clear')) return;
  gameState.activeItem = null;
  updateItemBar();

  gameState.isAnimating = true;

  const row = cell.row;
  let mossCleared = 0;
  let collected = 0;

  for (let c = 0; c < BOARD_SIZE; c++) {
    const boardCell = gameState.board[row][c];

    if (boardCell.blocker?.type === 'moss') {
      boardCell.blocker.layer--;
      if (boardCell.blocker.layer <= 0) {
        boardCell.blocker = null;
        mossCleared++;
      }
    }

    if (boardCell.tile) {
      if (gameState.goal.type === 'collect' && boardCell.tile.type === gameState.goal.item) {
        collected++;
      }
      boardCell.tile = null;
    }
  }

  if (gameState.goal.type === 'clear_moss') {
    gameState.goalProgress += mossCleared;
  } else {
    gameState.goalProgress += collected;
  }

  render();
  await sleep(150);
  await animateGravity();
  await animateFill();
  await resolveMatches();

  updateHUD();
  checkEndCondition();

  gameState.isAnimating = false;
}

// æ¸…åˆ—é“å…·
async function useColClearItem(cell) {
  if (!consumeItem('col_clear')) return;
  gameState.activeItem = null;
  updateItemBar();

  gameState.isAnimating = true;

  const col = cell.col;
  let mossCleared = 0;
  let collected = 0;

  for (let r = 0; r < BOARD_SIZE; r++) {
    const boardCell = gameState.board[r][col];

    if (boardCell.blocker?.type === 'moss') {
      boardCell.blocker.layer--;
      if (boardCell.blocker.layer <= 0) {
        boardCell.blocker = null;
        mossCleared++;
      }
    }

    if (boardCell.tile) {
      if (gameState.goal.type === 'collect' && boardCell.tile.type === gameState.goal.item) {
        collected++;
      }
      boardCell.tile = null;
    }
  }

  if (gameState.goal.type === 'clear_moss') {
    gameState.goalProgress += mossCleared;
  } else {
    gameState.goalProgress += collected;
  }

  render();
  await sleep(150);
  await animateGravity();
  await animateFill();
  await resolveMatches();

  updateHUD();
  checkEndCondition();

  gameState.isAnimating = false;
}

// ç‚¸å¼¹é“å…· (3x3)
async function useBombItem(cell) {
  if (!consumeItem('bomb')) return;
  gameState.activeItem = null;
  updateItemBar();

  gameState.isAnimating = true;

  let mossCleared = 0;
  let collected = 0;

  for (let dr = -1; dr <= 1; dr++) {
    for (let dc = -1; dc <= 1; dc++) {
      const r = cell.row + dr;
      const c = cell.col + dc;
      if (r < 0 || r >= BOARD_SIZE || c < 0 || c >= BOARD_SIZE) continue;

      const boardCell = gameState.board[r][c];

      if (boardCell.blocker?.type === 'moss') {
        boardCell.blocker.layer--;
        if (boardCell.blocker.layer <= 0) {
          boardCell.blocker = null;
          mossCleared++;
        }
      }

      if (boardCell.tile) {
        if (gameState.goal.type === 'collect' && boardCell.tile.type === gameState.goal.item) {
          collected++;
        }
        boardCell.tile = null;
      }
    }
  }

  if (gameState.goal.type === 'clear_moss') {
    gameState.goalProgress += mossCleared;
  } else {
    gameState.goalProgress += collected;
  }

  render();
  await sleep(150);
  await animateGravity();
  await animateFill();
  await resolveMatches();

  updateHUD();
  checkEndCondition();

  gameState.isAnimating = false;
}

// å¤„ç†é“å…·ç›®æ ‡é€‰æ‹©
function handleItemTargetSelect(cell) {
  if (!gameState.activeItem) return false;

  switch (gameState.activeItem) {
    case 'hammer':
      useHammerItem(cell);
      return true;
    case 'row_clear':
      useRowClearItem(cell);
      return true;
    case 'col_clear':
      useColClearItem(cell);
      return true;
    case 'bomb':
      useBombItem(cell);
      return true;
    default:
      return false;
  }
}

function consumeEnergy() {
  // æ–°æ‰‹ä¿æŠ¤ï¼šå‰Nå…³ä¸æ‰£ä½“åŠ›
  if (gameState.level <= ENERGY_CONFIG.newbieProtection) {
    return true;
  }

  if (gameState.energy.current <= 0) {
    return false;
  }

  gameState.energy.current--;
  if (gameState.energy.current < gameState.energy.max &&
      gameState.energy.lastRegenTime === 0) {
    gameState.energy.lastRegenTime = Date.now();
  }
  saveEnergyState();
  return true;
}

function getRegenTimeRemaining() {
  if (gameState.energy.current >= gameState.energy.max) {
    return 0;
  }
  const elapsed = Date.now() - gameState.energy.lastRegenTime;
  const remaining = (ENERGY_CONFIG.regenSeconds * 1000) - elapsed;
  return Math.max(0, remaining);
}

function formatTime(ms) {
  const totalSeconds = Math.ceil(ms / 1000);
  const minutes = Math.floor(totalSeconds / 60);
  const seconds = totalSeconds % 60;
  return `${minutes}:${seconds.toString().padStart(2, '0')}`;
}

function canWatchAd() {
  // æ£€æŸ¥æ¯å°æ—¶å¹¿å‘Šä¸Šé™
  const now = Date.now();
  if (now - gameState.energy.adHourStart > 3600000) {
    gameState.energy.adWatchedThisHour = 0;
    gameState.energy.adHourStart = now;
  }
  return gameState.energy.adWatchedThisHour < ENERGY_CONFIG.adHourlyCap &&
         gameState.energy.current < gameState.energy.max;
}

function watchAdForEnergy() {
  if (!canWatchAd()) {
    showMessage('æç¤º', 'å·²è¾¾åˆ°æ¯å°æ—¶è§‚çœ‹ä¸Šé™', () => {});
    setTimeout(hideMessage, 1500);
    return;
  }

  // æ¨¡æ‹Ÿå¹¿å‘Šè§‚çœ‹ï¼ˆå®é™…æ¥å…¥æ—¶æ›¿æ¢ï¼‰
  showMessage('è§‚çœ‹å¹¿å‘Š', 'æ¨¡æ‹Ÿå¹¿å‘Šæ’­æ”¾ä¸­...', null);
  setTimeout(() => {
    gameState.energy.current = Math.min(
      gameState.energy.max,
      gameState.energy.current + ENERGY_CONFIG.adReward
    );
    gameState.energy.adWatchedThisHour++;
    gameState.energy.lastRegenTime = Date.now();
    saveEnergyState();
    updateHUD();
    hideMessage();
    showMessage('è·å¾—ä½“åŠ›', `+${ENERGY_CONFIG.adReward} ä½“åŠ›`, () => {});
    setTimeout(hideMessage, 1000);
  }, 1500);
}

// ä½“åŠ›æ¢å¤å®šæ—¶å™¨
let energyTimer = null;
function startEnergyTimer() {
  if (energyTimer) clearInterval(energyTimer);
  energyTimer = setInterval(() => {
    if (gameState.energy.current < gameState.energy.max) {
      const elapsed = Date.now() - gameState.energy.lastRegenTime;
      if (elapsed >= ENERGY_CONFIG.regenSeconds * 1000) {
        gameState.energy.current++;
        gameState.energy.lastRegenTime = Date.now();
        saveEnergyState();
      }
    }
    updateEnergyDisplay();
  }, 1000);
}

function updateEnergyDisplay() {
  const energyEl = document.getElementById('energy');
  const timerEl = document.getElementById('energyTimer');

  energyEl.textContent = `${gameState.energy.current}/${gameState.energy.max}`;

  if (gameState.energy.current < gameState.energy.max) {
    const remaining = getRegenTimeRemaining();
    if (timerEl) timerEl.textContent = formatTime(remaining);
  } else {
    if (timerEl) timerEl.textContent = 'å·²æ»¡';
  }

  // æ›´æ–°ä½“åŠ›é—¨æ§›å¼¹çª—ä¸­çš„æ˜¾ç¤º
  const gateCurrent = document.getElementById('gateEnergyCurrent');
  const gateMax = document.getElementById('gateEnergyMax');
  const gateTimer = document.getElementById('gateEnergyTimer');
  const adRemaining = document.getElementById('adRemaining');

  if (gateCurrent) gateCurrent.textContent = gameState.energy.current;
  if (gateMax) gateMax.textContent = gameState.energy.max;
  if (gateTimer) {
    const remaining = getRegenTimeRemaining();
    gateTimer.textContent = remaining > 0 ? formatTime(remaining) : 'å·²æ»¡';
  }
  if (adRemaining) {
    adRemaining.textContent = ENERGY_CONFIG.adHourlyCap - gameState.energy.adWatchedThisHour;
  }
}

function showEnergyGate() {
  updateEnergyDisplay();
  document.getElementById('energyGate').style.display = 'flex';
}

function hideEnergyGate() {
  document.getElementById('energyGate').style.display = 'none';
}

function tryStartLevel(levelIndex) {
  // æ–°æ‰‹ä¿æŠ¤æœŸä¸æ£€æŸ¥ä½“åŠ›
  if (levelIndex <= ENERGY_CONFIG.newbieProtection) {
    initGame(levelIndex);
    return;
  }

  // æ£€æŸ¥ä½“åŠ›
  if (gameState.energy.current <= 0) {
    showEnergyGate();
    return;
  }

  // æ¶ˆè€—ä½“åŠ›å¹¶å¼€å§‹æ¸¸æˆ
  if (consumeEnergy()) {
    initGame(levelIndex);
  } else {
    showEnergyGate();
  }
}

// --- Canvas ç›¸å…³ ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// --- åˆå§‹åŒ–æ¸¸æˆ ---
function initGame(levelIndex) {
  const config = getLevelConfig(levelIndex);
  gameState.level = levelIndex;
  gameState.moves = config.moves;

  // Boss å…³å¡ç‰¹æ®Šæ ‡è®°
  if (config.isBossLevel) {
    document.querySelector('.title').textContent = `ğŸ”¥ BOSS ç¬¬${levelIndex}å…³ ğŸ”¥`;
  } else {
    document.querySelector('.title').textContent = 'ç¯ç¬¼å¶å­æ¶ˆæ¶ˆä¹';
  }
  gameState.goalProgress = 0;
  gameState.selectedCell = null;
  gameState.isAnimating = false;
  gameState.rng = new RNG(Date.now() + levelIndex * 1000);

  // é‡ç½®é“å…·å…³å¡çŠ¶æ€
  resetLevelItemState();
  updateItemBar();

  // é‡ç½®å¹¿å‘Šå…³å¡çŠ¶æ€
  resetLevelAdState();

  // è®¾ç½®ç›®æ ‡
  if (config.goal === 'collect') {
    gameState.goal = { type: 'collect', item: config.item, count: config.count };
  } else {
    gameState.goal = { type: 'clear_moss', count: config.count };
  }

  // ç”Ÿæˆè‹”è—“
  const patternCells = MOSS_PATTERNS[config.pattern] || [];
  const mossCount = Math.round(patternCells.length * config.density);
  const mossCells = gameState.rng.sample(patternCells, mossCount);
  const mossSet = new Set(mossCells.map(c => `${c.row},${c.col}`));

  // ç”Ÿæˆæ£‹ç›˜
  gameState.board = [];
  for (let r = 0; r < BOARD_SIZE; r++) {
    const row = [];
    for (let c = 0; c < BOARD_SIZE; c++) {
      row.push({
        tile: { type: randomTileType(), isSpecial: false },
        blocker: mossSet.has(`${r},${c}`) ? { type: 'moss', layer: 1 } : null
      });
    }
    gameState.board.push(row);
  }

  // ç§»é™¤åˆå§‹åŒ¹é…
  removeInitialMatches();

  // ç¡®ä¿æœ‰æœ‰æ•ˆç§»åŠ¨
  if (!hasValidMove()) {
    shuffleBoard();
  }

  // æ›´æ–° UI
  updateHUD();
  render();
}

function randomTileType() {
  return TILE_TYPES[gameState.rng.randInt(0, TILE_TYPES.length - 1)];
}

function removeInitialMatches() {
  let matches = findAllMatches();
  let iterations = 0;
  while (matches.length > 0 && iterations < 100) {
    for (const match of matches) {
      const cell = match.cells[Math.floor(match.cells.length / 2)];
      const oldType = gameState.board[cell.row][cell.col].tile.type;
      const otherTypes = TILE_TYPES.filter(t => t !== oldType);
      gameState.board[cell.row][cell.col].tile.type = otherTypes[gameState.rng.randInt(0, otherTypes.length - 1)];
    }
    matches = findAllMatches();
    iterations++;
  }
}

// --- åŒ¹é…æ£€æµ‹ ---
function findAllMatches() {
  const horizontalMatches = [];
  const verticalMatches = [];

  // æ°´å¹³
  for (let r = 0; r < BOARD_SIZE; r++) {
    let c = 0;
    while (c < BOARD_SIZE) {
      const tile = gameState.board[r][c].tile;
      if (!tile) { c++; continue; }
      // æ£€æŸ¥ç™¾æ­å—æˆ–æ™®é€šåŒ¹é…
      const type = tile.isWildcard ? null : tile.type;
      let len = 1;
      while (c + len < BOARD_SIZE) {
        const nextTile = gameState.board[r][c + len].tile;
        if (!nextTile) break;
        // ç™¾æ­å—å¯ä»¥ä¸ä»»æ„é¢œè‰²åŒ¹é…
        if (nextTile.isWildcard || tile.isWildcard || nextTile.type === type) {
          len++;
        } else {
          break;
        }
      }
      if (len >= 3) {
        const cells = [];
        const actualType = tile.isWildcard
          ? gameState.board[r][c + 1]?.tile?.type || 'leaf'
          : type;
        for (let i = 0; i < len; i++) cells.push({row: r, col: c + i});
        horizontalMatches.push({ cells, type: actualType, length: len, isHorizontal: true, shape: 'linear' });
      }
      c += len;
    }
  }

  // å‚ç›´
  for (let c = 0; c < BOARD_SIZE; c++) {
    let r = 0;
    while (r < BOARD_SIZE) {
      const tile = gameState.board[r][c].tile;
      if (!tile) { r++; continue; }
      const type = tile.isWildcard ? null : tile.type;
      let len = 1;
      while (r + len < BOARD_SIZE) {
        const nextTile = gameState.board[r + len][c].tile;
        if (!nextTile) break;
        if (nextTile.isWildcard || tile.isWildcard || nextTile.type === type) {
          len++;
        } else {
          break;
        }
      }
      if (len >= 3) {
        const cells = [];
        const actualType = tile.isWildcard
          ? gameState.board[r + 1]?.[c]?.tile?.type || 'leaf'
          : type;
        for (let i = 0; i < len; i++) cells.push({row: r + i, col: c});
        verticalMatches.push({ cells, type: actualType, length: len, isHorizontal: false, shape: 'linear' });
      }
      r += len;
    }
  }

  // æ£€æµ‹ Tå‹ å’Œ Lå‹
  const allMatches = [...horizontalMatches, ...verticalMatches];
  detectTLShapes(horizontalMatches, verticalMatches, allMatches);

  return allMatches;
}

// æ£€æµ‹ Tå‹ å’Œ Lå‹ åŒ¹é…
function detectTLShapes(horizontalMatches, verticalMatches, allMatches) {
  for (const hMatch of horizontalMatches) {
    for (const vMatch of verticalMatches) {
      if (hMatch.type !== vMatch.type) continue;

      // æŸ¥æ‰¾äº¤å‰ç‚¹
      for (const hCell of hMatch.cells) {
        for (const vCell of vMatch.cells) {
          if (hCell.row === vCell.row && hCell.col === vCell.col) {
            // æ‰¾åˆ°äº¤å‰ç‚¹
            const isCorner = isCornerIntersection(hMatch, vMatch, hCell);
            const shape = isCorner ? 'L' : 'T';

            // æ ‡è®°è¿™ä¸¤ä¸ªåŒ¹é…
            hMatch.shape = shape;
            vMatch.shape = shape;
            hMatch.intersectionCell = hCell;
            vMatch.intersectionCell = hCell;
          }
        }
      }
    }
  }
}

// æ£€æŸ¥æ˜¯å¦ä¸ºè§’è½äº¤å‰ï¼ˆLå‹ï¼‰
function isCornerIntersection(hMatch, vMatch, intersection) {
  const hCells = hMatch.cells;
  const vCells = vMatch.cells;

  // æ£€æŸ¥æ˜¯å¦æ˜¯æ°´å¹³åŒ¹é…çš„ç«¯ç‚¹
  const isHEnd = (intersection.col === hCells[0].col || intersection.col === hCells[hCells.length - 1].col);
  // æ£€æŸ¥æ˜¯å¦æ˜¯å‚ç›´åŒ¹é…çš„ç«¯ç‚¹
  const isVEnd = (intersection.row === vCells[0].row || intersection.row === vCells[vCells.length - 1].row);

  return isHEnd && isVEnd;
}

function wouldSwapMatch(from, to) {
  // æ¨¡æ‹Ÿäº¤æ¢
  const tempTile = gameState.board[from.row][from.col].tile;
  gameState.board[from.row][from.col].tile = gameState.board[to.row][to.col].tile;
  gameState.board[to.row][to.col].tile = tempTile;

  const hasMatch = hasMatchAt(from) || hasMatchAt(to);

  // æ¢å›
  gameState.board[to.row][to.col].tile = gameState.board[from.row][from.col].tile;
  gameState.board[from.row][from.col].tile = tempTile;

  return hasMatch;
}

function hasMatchAt(cell) {
  const tile = gameState.board[cell.row][cell.col].tile;
  if (!tile) return false;
  const type = tile.type;

  // æ°´å¹³
  let hCount = 1;
  for (let c = cell.col - 1; c >= 0 && gameState.board[cell.row][c].tile?.type === type; c--) hCount++;
  for (let c = cell.col + 1; c < BOARD_SIZE && gameState.board[cell.row][c].tile?.type === type; c++) hCount++;
  if (hCount >= 3) return true;

  // å‚ç›´
  let vCount = 1;
  for (let r = cell.row - 1; r >= 0 && gameState.board[r][cell.col].tile?.type === type; r--) vCount++;
  for (let r = cell.row + 1; r < BOARD_SIZE && gameState.board[r][cell.col].tile?.type === type; r++) vCount++;
  return vCount >= 3;
}

function hasValidMove() {
  for (let r = 0; r < BOARD_SIZE; r++) {
    for (let c = 0; c < BOARD_SIZE; c++) {
      if (c < BOARD_SIZE - 1 && wouldSwapMatch({row: r, col: c}, {row: r, col: c + 1})) return true;
      if (r < BOARD_SIZE - 1 && wouldSwapMatch({row: r, col: c}, {row: r + 1, col: c})) return true;
    }
  }
  return false;
}

function getValidMove() {
  for (let r = 0; r < BOARD_SIZE; r++) {
    for (let c = 0; c < BOARD_SIZE; c++) {
      if (c < BOARD_SIZE - 1 && wouldSwapMatch({row: r, col: c}, {row: r, col: c + 1})) {
        return { from: {row: r, col: c}, to: {row: r, col: c + 1} };
      }
      if (r < BOARD_SIZE - 1 && wouldSwapMatch({row: r, col: c}, {row: r + 1, col: c})) {
        return { from: {row: r, col: c}, to: {row: r + 1, col: c} };
      }
    }
  }
  return null;
}

function shuffleBoard() {
  const tiles = [];
  for (let r = 0; r < BOARD_SIZE; r++) {
    for (let c = 0; c < BOARD_SIZE; c++) {
      if (gameState.board[r][c].tile) {
        tiles.push(gameState.board[r][c].tile);
      }
    }
  }
  const shuffled = gameState.rng.shuffle(tiles);
  let idx = 0;
  for (let r = 0; r < BOARD_SIZE; r++) {
    for (let c = 0; c < BOARD_SIZE; c++) {
      if (gameState.board[r][c].tile) {
        gameState.board[r][c].tile = shuffled[idx++];
      }
    }
  }
  removeInitialMatches();
  showMessage('æ´—ç‰Œ', 'æ£‹ç›˜å·²åˆ·æ–°', () => {});
  setTimeout(() => hideMessage(), 800);
}

// --- ç‰¹æ®Šå—è§¦å‘æ•ˆæœ ---
function triggerSpecialTile(cell, clearedCells, totalCollected, triggeredSpecials, targetType = null) {
  const tile = gameState.board[cell.row][cell.col].tile;
  if (!tile?.isSpecial) return { collected: {}, mossCleared: 0, multiplier: 1 };

  const key = `${cell.row},${cell.col}`;
  if (triggeredSpecials.has(key)) return { collected: {}, mossCleared: 0, multiplier: 1 };
  triggeredSpecials.add(key);

  const affectedCells = [];
  let multiplier = 1;

  switch (tile.specialType) {
    case 'whirl_h': // æ¸…é™¤æ•´è¡Œ
      for (let c = 0; c < BOARD_SIZE; c++) {
        affectedCells.push({ row: cell.row, col: c });
      }
      break;

    case 'whirl_v': // æ¸…é™¤æ•´åˆ—
      for (let r = 0; r < BOARD_SIZE; r++) {
        affectedCells.push({ row: r, col: cell.col });
      }
      break;

    case 'lantern': // æ¸…é™¤ 3x3 åŒºåŸŸ
      for (let dr = -1; dr <= 1; dr++) {
        for (let dc = -1; dc <= 1; dc++) {
          const r = cell.row + dr;
          const c = cell.col + dc;
          if (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE) {
            affectedCells.push({ row: r, col: c });
          }
        }
      }
      break;

    case 'rainbow': // æ¶ˆé™¤æ‰€æœ‰åŒè‰²
      const colorToRemove = targetType || getRandomTileType();
      for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
          const t = gameState.board[r][c].tile;
          if (t && t.type === colorToRemove) {
            affectedCells.push({ row: r, col: c });
          }
        }
      }
      // ä¹Ÿæ¸…é™¤å½©è™¹å—æœ¬èº«
      affectedCells.push(cell);
      break;

    case 'multiplier': // å€æ•°å—ï¼Œæ”¶é›†æ—¶Ã—2
      multiplier = tile.multiplierValue || 2;
      affectedCells.push(cell);
      break;

    case 'wildcard': // ç™¾æ­å—ï¼Œæ­£å¸¸æ¸…é™¤
      affectedCells.push(cell);
      break;

    case 'bomb_timer': // ç‚¸å¼¹ï¼Œæ­£å¸¸æ¸…é™¤ï¼ˆè§£é™¤å±æœºï¼‰
      affectedCells.push(cell);
      break;
  }

  let mossCleared = 0;
  const collected = {};

  // æ¸…é™¤å—å½±å“çš„æ ¼å­
  for (const c of affectedCells) {
    const cellKey = `${c.row},${c.col}`;
    if (clearedCells.has(cellKey)) continue;
    clearedCells.add(cellKey);

    const boardCell = gameState.board[c.row][c.col];

    // å¤„ç†å†°å†»å—
    if (boardCell.tile?.specialType === 'frozen' && boardCell.tile.frozenLayers > 0) {
      boardCell.tile.frozenLayers--;
      if (boardCell.tile.frozenLayers > 0) {
        clearedCells.delete(cellKey);  // è¿˜æ²¡å®Œå…¨æ¶ˆé™¤
        continue;
      }
    }

    // ç»Ÿè®¡æ”¶é›†
    if (boardCell.tile) {
      const collectCount = boardCell.tile.specialType === 'multiplier'
        ? (boardCell.tile.multiplierValue || 2)
        : 1;
      collected[boardCell.tile.type] = (collected[boardCell.tile.type] || 0) + collectCount;

      // è¿é”è§¦å‘å…¶ä»–ç‰¹æ®Šå—
      if (boardCell.tile.isSpecial && cellKey !== key && boardCell.tile.specialType !== 'frozen') {
        const chainResult = triggerSpecialTile(c, clearedCells, totalCollected, triggeredSpecials);
        for (const [t, n] of Object.entries(chainResult.collected)) {
          collected[t] = (collected[t] || 0) + n;
        }
        mossCleared += chainResult.mossCleared;
      }
    }

    // å¤„ç†è‹”è—“
    if (boardCell.blocker?.type === 'moss') {
      boardCell.blocker.layer--;
      if (boardCell.blocker.layer <= 0) {
        boardCell.blocker = null;
        mossCleared++;
      }
    }

    // æ¸…é™¤ tile
    boardCell.tile = null;
  }

  return { collected, mossCleared, multiplier };
}

// è·å–éšæœºæ–¹å—ç±»å‹
function getRandomTileType() {
  return TILE_TYPES[Math.floor(Math.random() * TILE_TYPES.length)];
}

// --- æ¶ˆé™¤å¤„ç† ---
async function resolveMatches() {
  let cascadeCount = 0;
  let totalCollected = {};
  let totalMossCleared = 0;

  while (true) {
    const matches = findAllMatches();
    if (matches.length === 0) break;

    cascadeCount++;
    if (cascadeCount > 1) {
      showCombo(cascadeCount);

      // æ›´æ–°è¿æ¶ˆç»Ÿè®¡
      if (cascadeCount > comboStats.sessionMax) {
        comboStats.sessionMax = cascadeCount;
      }
      if (cascadeCount > comboStats.allTimeMax) {
        comboStats.allTimeMax = cascadeCount;
        saveComboStats();
      }
    }

    // å¤„ç†æ¯ä¸ªåŒ¹é…
    const clearedCells = new Set();
    const triggeredSpecials = new Set();
    const specialsToCreate = [];  // å»¶è¿Ÿåˆ›å»ºç‰¹æ®Šå—
    const processedTLIntersections = new Set();  // å·²å¤„ç†çš„ T/L äº¤å‰ç‚¹

    for (const match of matches) {
      // æ”¶é›†ç»Ÿè®¡
      totalCollected[match.type] = (totalCollected[match.type] || 0) + match.cells.length;

      // ç¡®å®šç‰¹æ®Šå—ä½ç½®
      let centerCell;
      let specialType = null;

      // æ£€æŸ¥æ˜¯å¦ä¸º T/L å‹åŒ¹é…
      if ((match.shape === 'T' || match.shape === 'L') && match.intersectionCell) {
        const intKey = `${match.intersectionCell.row},${match.intersectionCell.col}`;
        if (!processedTLIntersections.has(intKey)) {
          processedTLIntersections.add(intKey);
          centerCell = match.intersectionCell;
          specialType = 'rainbow';  // T/L å‹ç”Ÿæˆå½©è™¹å—
        }
      } else if (match.length >= 5) {
        centerCell = match.cells[Math.floor(match.cells.length / 2)];
        specialType = 'lantern';
      } else if (match.length >= 4) {
        centerCell = match.cells[Math.floor(match.cells.length / 2)];
        specialType = match.isHorizontal ? 'whirl_h' : 'whirl_v';
      }

      for (let i = 0; i < match.cells.length; i++) {
        const cell = match.cells[i];
        const key = `${cell.row},${cell.col}`;
        if (clearedCells.has(key)) continue;

        const boardCell = gameState.board[cell.row][cell.col];

        // å¤„ç†å†°å†»å—
        if (boardCell.tile?.specialType === 'frozen' && boardCell.tile.frozenLayers > 0) {
          boardCell.tile.frozenLayers--;
          if (boardCell.tile.frozenLayers > 0) {
            continue;  // å†°å±‚è¿˜æ²¡æ¶ˆå®Œ
          }
        }

        // æ£€æŸ¥æ˜¯å¦æ˜¯ç‰¹æ®Šå—ï¼Œè§¦å‘æ•ˆæœ
        if (boardCell.tile?.isSpecial && boardCell.tile.specialType !== 'frozen') {
          const result = triggerSpecialTile(cell, clearedCells, totalCollected, triggeredSpecials);
          for (const [t, n] of Object.entries(result.collected)) {
            totalCollected[t] = (totalCollected[t] || 0) + n;
          }
          totalMossCleared += result.mossCleared;
          continue;
        }

        clearedCells.add(key);

        // å¤„ç†è‹”è—“
        if (boardCell.blocker?.type === 'moss') {
          boardCell.blocker.layer--;
          if (boardCell.blocker.layer <= 0) {
            boardCell.blocker = null;
            totalMossCleared++;
          }
        }

        // æ¸…é™¤ tileï¼ˆç‰¹æ®Šå—ç”Ÿæˆä½ç½®é™¤å¤–ï¼‰
        const isCenterForSpecial = centerCell && cell.row === centerCell.row && cell.col === centerCell.col && specialType;
        if (!isCenterForSpecial) {
          boardCell.tile = null;
        }
      }

      // è®°å½•éœ€è¦ç”Ÿæˆçš„ç‰¹æ®Šå—
      if (specialType && centerCell) {
        const existingIdx = specialsToCreate.findIndex(s =>
          s.cell.row === centerCell.row && s.cell.col === centerCell.col
        );
        if (existingIdx === -1) {
          specialsToCreate.push({
            cell: centerCell,
            type: match.type,
            specialType
          });
        }
      }
    }

    // åˆ›å»ºç‰¹æ®Šå—
    for (const special of specialsToCreate) {
      gameState.board[special.cell.row][special.cell.col].tile = {
        type: special.type,
        isSpecial: true,
        specialType: special.specialType
      };
    }

    render();
    await sleep(150);

    // ä¸‹è½ï¼ˆå¸¦åŠ¨ç”»ï¼‰
    await animateGravity();

    // å¡«å……ï¼ˆå¸¦åŠ¨ç”»ï¼‰
    await animateFill();

    // ç”Ÿæˆè¿æ¶ˆå¥–åŠ±å—
    if (cascadeCount >= 3) {
      const rewardPlaced = generateComboReward(cascadeCount);
      if (rewardPlaced) {
        render();
        await sleep(200);
      }
    }
  }

  // æ›´æ–°ç›®æ ‡è¿›åº¦
  if (gameState.goal.type === 'collect') {
    gameState.goalProgress += totalCollected[gameState.goal.item] || 0;
  } else {
    gameState.goalProgress += totalMossCleared;
  }

  updateHUD();

  // æ£€æŸ¥æ­»å±€
  if (!hasValidMove()) {
    shuffleBoard();
    render();
  }
}

// ç”Ÿæˆè¿æ¶ˆå¥–åŠ±å—
function generateComboReward(comboLevel) {
  // ç¡®å®šå¥–åŠ±ç±»å‹
  let rewardType;
  if (comboLevel >= 5) {
    rewardType = COMBO_REWARDS[5].type;
  } else if (comboLevel >= 4) {
    rewardType = COMBO_REWARDS[4].type;
  } else if (comboLevel >= 3) {
    rewardType = COMBO_REWARDS[3].type;
  } else {
    return false;
  }

  // æ‰¾ä¸€ä¸ªéšæœºç©ºä½ç½®æ”¾ç½®å¥–åŠ±å—
  const emptyCells = [];
  for (let r = 0; r < BOARD_SIZE; r++) {
    for (let c = 0; c < BOARD_SIZE; c++) {
      const cell = gameState.board[r][c];
      if (cell.tile && !cell.tile.isSpecial && !cell.blocker) {
        emptyCells.push({ row: r, col: c });
      }
    }
  }

  if (emptyCells.length === 0) {
    return false;
  }

  // éšæœºé€‰æ‹©ä¸€ä¸ªä½ç½®
  const targetCell = emptyCells[gameState.rng.randInt(0, emptyCells.length - 1)];
  const tile = gameState.board[targetCell.row][targetCell.col].tile;

  // å°†è¯¥ä½ç½®çš„æ–¹å—è½¬æ¢ä¸ºç‰¹æ®Šå—
  tile.isSpecial = true;
  tile.specialType = rewardType;

  if (rewardType === 'multiplier') {
    tile.multiplierValue = 2;
  } else if (rewardType === 'wildcard') {
    tile.isWildcard = true;
  }

  // æ˜¾ç¤ºå¥–åŠ±æç¤º
  showComboRewardMessage(comboLevel, rewardType);

  return true;
}

// æ˜¾ç¤ºè¿æ¶ˆå¥–åŠ±æ¶ˆæ¯
function showComboRewardMessage(comboLevel, rewardType) {
  const messages = {
    multiplier: 'è·å¾— Ã—2 å€æ•°å—!',
    wildcard: 'è·å¾—ç™¾æ­å—!',
    rainbow: 'è·å¾—å½©è™¹å—!'
  };

  const comboText = document.getElementById('comboText');
  comboText.innerHTML = `è¿æ¶ˆ x${comboLevel}!<br><span style="font-size:24px;color:#4CAF50">${messages[rewardType] || ''}</span>`;
  comboText.style.opacity = 1;

  // æ ¹æ®è¿æ¶ˆç­‰çº§è°ƒæ•´æ ·å¼
  const style = COMBO_STYLES[Math.min(comboLevel, 5)];
  comboText.style.color = style.color;

  if (style.size === 'large') {
    comboText.style.fontSize = '56px';
  } else if (style.size === 'larger') {
    comboText.style.fontSize = '64px';
  } else if (style.size === 'largest') {
    comboText.style.fontSize = '72px';
  } else {
    comboText.style.fontSize = '48px';
  }

  setTimeout(() => {
    comboText.style.opacity = 0;
    comboText.style.fontSize = '48px';
    comboText.style.color = '#ffd700';
  }, 1200);
}

// æ›´æ–°ç‚¸å¼¹å€’è®¡æ—¶ï¼ˆæ¯æ¬¡ç§»åŠ¨åè°ƒç”¨ï¼‰
function updateBombTimers() {
  let bombExploded = false;

  for (let r = 0; r < BOARD_SIZE; r++) {
    for (let c = 0; c < BOARD_SIZE; c++) {
      const tile = gameState.board[r][c].tile;
      if (tile?.specialType === 'bomb_timer' && tile.bombTimer !== undefined) {
        tile.bombTimer--;
        if (tile.bombTimer <= 0) {
          bombExploded = true;
        }
      }
    }
  }

  return bombExploded;
}

function applyGravity() {
  for (let c = 0; c < BOARD_SIZE; c++) {
    let writeRow = BOARD_SIZE - 1;
    for (let r = BOARD_SIZE - 1; r >= 0; r--) {
      if (gameState.board[r][c].tile !== null) {
        if (r !== writeRow) {
          gameState.board[writeRow][c].tile = gameState.board[r][c].tile;
          gameState.board[r][c].tile = null;
        }
        writeRow--;
      }
    }
  }
}

function fillEmpty() {
  for (let c = 0; c < BOARD_SIZE; c++) {
    for (let r = 0; r < BOARD_SIZE; r++) {
      if (gameState.board[r][c].tile === null) {
        const tile = generateNewTile();
        gameState.board[r][c].tile = tile;
      }
    }
  }
}

// ç”Ÿæˆæ–°æ–¹å—ï¼ˆå¯èƒ½æ˜¯ç‰¹æ®Šæ–¹å—ï¼‰
function generateNewTile() {
  const type = randomTileType();
  const tile = { type, isSpecial: false };

  // æ ¹æ®å…³å¡æ£€æŸ¥æ˜¯å¦ç”Ÿæˆç‰¹æ®Šå—
  const level = gameState.level;

  // æ£€æŸ¥æ¯ç§ç‰¹æ®Šå—
  for (const [specialType, config] of Object.entries(SPECIAL_GENERATION)) {
    if (level >= config.minLevel && gameState.rng.random() < config.probability) {
      tile.isSpecial = true;
      tile.specialType = specialType;

      // è®¾ç½®ç‰¹æ®Šå±æ€§
      if (specialType === 'frozen') {
        tile.frozenLayers = 2;
      } else if (specialType === 'multiplier') {
        tile.multiplierValue = 2;
      } else if (specialType === 'wildcard') {
        tile.isWildcard = true;
      } else if (specialType === 'bomb_timer') {
        tile.bombTimer = gameState.rng.randInt(5, 8);
      }

      return tile;
    }
  }

  return tile;
}

// --- ç®€åŒ–çš„å è½åŠ¨ç”» ---
async function animateGravity() {
  // ç›´æ¥åº”ç”¨é‡åŠ›å¹¶æ¸²æŸ“
  applyGravity();
  render();
  await sleep(80);
}

// --- ç®€åŒ–çš„å¡«å……åŠ¨ç”» ---
async function animateFill() {
  // ç›´æ¥å¡«å……å¹¶æ¸²æŸ“
  fillEmpty();
  render();
  await sleep(80);
}

// --- ç‰¹æ®Šå—ç»„åˆæ•ˆæœ ---
function isSpecialTile(tile) {
  return tile?.isSpecial && ['whirl_h', 'whirl_v', 'lantern', 'rainbow'].includes(tile.specialType);
}

function getSpecialComboType(type1, type2) {
  const types = [type1, type2].sort();

  // whirl + whirl = åå­—æ¸…é™¤
  if ((type1 === 'whirl_h' && type2 === 'whirl_v') || (type1 === 'whirl_v' && type2 === 'whirl_h')) {
    return 'cross';
  }

  // whirl + lantern = 3è¡Œ/3åˆ—æ¸…é™¤
  if ((type1.startsWith('whirl') && type2 === 'lantern') || (type1 === 'lantern' && type2.startsWith('whirl'))) {
    return 'triple_line';
  }

  // lantern + lantern = 5x5 æ¸…é™¤
  if (type1 === 'lantern' && type2 === 'lantern') {
    return 'mega_bomb';
  }

  // rainbow + ç‰¹æ®Šå— = å…¨è‰²å˜ç‰¹æ®Š
  if (type1 === 'rainbow' || type2 === 'rainbow') {
    const otherType = type1 === 'rainbow' ? type2 : type1;
    if (otherType !== 'rainbow') {
      return 'rainbow_special';
    }
    // rainbow + rainbow = å…¨å±æ¸…é™¤
    return 'rainbow_rainbow';
  }

  return null;
}

async function triggerSpecialCombo(cell1, cell2, comboType) {
  const tile1 = gameState.board[cell1.row][cell1.col].tile;
  const tile2 = gameState.board[cell2.row][cell2.col].tile;

  const clearedCells = new Set();
  const triggeredSpecials = new Set();
  let totalCollected = {};
  let totalMossCleared = 0;

  // å…ˆæ¸…é™¤ä¸¤ä¸ªç‰¹æ®Šå—æœ¬èº«
  clearedCells.add(`${cell1.row},${cell1.col}`);
  clearedCells.add(`${cell2.row},${cell2.col}`);

  const affectedCells = [];

  switch (comboType) {
    case 'cross': // åå­—æ¸…é™¤ï¼ˆæ•´è¡Œ+æ•´åˆ—ï¼‰
      for (let c = 0; c < BOARD_SIZE; c++) {
        affectedCells.push({ row: cell1.row, col: c });
        affectedCells.push({ row: cell2.row, col: c });
      }
      for (let r = 0; r < BOARD_SIZE; r++) {
        affectedCells.push({ row: r, col: cell1.col });
        affectedCells.push({ row: r, col: cell2.col });
      }
      showComboEffect('åå­—æ¶ˆé™¤!');
      break;

    case 'triple_line': // 3è¡Œæˆ–3åˆ—æ¸…é™¤
      const isHorizontal = tile1.specialType === 'whirl_h' || tile2.specialType === 'whirl_h';
      if (isHorizontal) {
        // æ¸…é™¤ä¸­å¿ƒè¡ŒåŠä¸Šä¸‹å„ä¸€è¡Œ
        for (let dr = -1; dr <= 1; dr++) {
          const r = cell1.row + dr;
          if (r >= 0 && r < BOARD_SIZE) {
            for (let c = 0; c < BOARD_SIZE; c++) {
              affectedCells.push({ row: r, col: c });
            }
          }
        }
      } else {
        // æ¸…é™¤ä¸­å¿ƒåˆ—åŠå·¦å³å„ä¸€åˆ—
        for (let dc = -1; dc <= 1; dc++) {
          const c = cell1.col + dc;
          if (c >= 0 && c < BOARD_SIZE) {
            for (let r = 0; r < BOARD_SIZE; r++) {
              affectedCells.push({ row: r, col: c });
            }
          }
        }
      }
      showComboEffect('ä¸‰çº¿çˆ†ç ´!');
      break;

    case 'mega_bomb': // 5x5 èŒƒå›´æ¸…é™¤
      for (let dr = -2; dr <= 2; dr++) {
        for (let dc = -2; dc <= 2; dc++) {
          const r = cell1.row + dr;
          const c = cell1.col + dc;
          if (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE) {
            affectedCells.push({ row: r, col: c });
          }
        }
      }
      showComboEffect('è¶…çº§çˆ†ç ´!');
      break;

    case 'rainbow_special': // å…¨è‰²å˜ç‰¹æ®Šå—å¹¶è§¦å‘
      const otherTile = tile1.specialType === 'rainbow' ? tile2 : tile1;
      const targetType = getRandomTileType();

      // æ‰¾åˆ°æ‰€æœ‰è¯¥é¢œè‰²çš„æ ¼å­ï¼Œå˜æˆç‰¹æ®Šå—å¹¶è§¦å‘
      for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
          const t = gameState.board[r][c].tile;
          if (t && t.type === targetType && !t.isSpecial) {
            // æŠŠæ™®é€šå—å˜æˆç‰¹æ®Šå—
            gameState.board[r][c].tile = {
              ...t,
              isSpecial: true,
              specialType: otherTile.specialType
            };
            affectedCells.push({ row: r, col: c });
          }
        }
      }
      // ä¹Ÿæ¸…é™¤å½©è™¹å—å’Œå¦ä¸€ä¸ªç‰¹æ®Šå—çš„ä½ç½®
      affectedCells.push(cell1);
      affectedCells.push(cell2);
      showComboEffect('å½©è™¹çˆ†å‘!');
      break;

    case 'rainbow_rainbow': // å…¨å±æ¸…é™¤
      for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
          affectedCells.push({ row: r, col: c });
        }
      }
      showComboEffect('å…¨å±æ¸…é™¤!');
      break;
  }

  // æ¸…é™¤å—å½±å“çš„æ ¼å­
  for (const cell of affectedCells) {
    const key = `${cell.row},${cell.col}`;
    if (clearedCells.has(key)) continue;
    clearedCells.add(key);

    const boardCell = gameState.board[cell.row][cell.col];

    // å¤„ç†å†°å†»å—
    if (boardCell.tile?.specialType === 'frozen' && boardCell.tile.frozenLayers > 0) {
      boardCell.tile.frozenLayers--;
      if (boardCell.tile.frozenLayers > 0) {
        clearedCells.delete(key);
        continue;
      }
    }

    // ç»Ÿè®¡æ”¶é›†
    if (boardCell.tile) {
      const collectCount = boardCell.tile.specialType === 'multiplier'
        ? (boardCell.tile.multiplierValue || 2)
        : 1;
      totalCollected[boardCell.tile.type] = (totalCollected[boardCell.tile.type] || 0) + collectCount;

      // è¿é”è§¦å‘å…¶ä»–ç‰¹æ®Šå—
      if (boardCell.tile.isSpecial && boardCell.tile.specialType !== 'frozen') {
        const chainResult = triggerSpecialTile(cell, clearedCells, totalCollected, triggeredSpecials);
        for (const [t, n] of Object.entries(chainResult.collected)) {
          totalCollected[t] = (totalCollected[t] || 0) + n;
        }
        totalMossCleared += chainResult.mossCleared;
      }
    }

    // å¤„ç†è‹”è—“
    if (boardCell.blocker?.type === 'moss') {
      boardCell.blocker.layer--;
      if (boardCell.blocker.layer <= 0) {
        boardCell.blocker = null;
        totalMossCleared++;
      }
    }

    // æ¸…é™¤ tile
    boardCell.tile = null;
  }

  // æ›´æ–°ç›®æ ‡è¿›åº¦
  for (const [type, count] of Object.entries(totalCollected)) {
    const goal = gameState.goals.find(g => g.type === 'collect' && g.item === type);
    if (goal) {
      goal.current = Math.min(goal.count, goal.current + count);
    }
  }

  const mossGoal = gameState.goals.find(g => g.type === 'clear_moss');
  if (mossGoal && totalMossCleared > 0) {
    mossGoal.current = Math.min(mossGoal.count, mossGoal.current + totalMossCleared);
  }

  return { collected: totalCollected, mossCleared: totalMossCleared };
}

function showComboEffect(text) {
  const comboDiv = document.createElement('div');
  comboDiv.style.cssText = `
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: linear-gradient(135deg, #FFD700, #FFA500);
    color: #333;
    font-size: 28px;
    font-weight: bold;
    padding: 15px 30px;
    border-radius: 15px;
    box-shadow: 0 4px 20px rgba(255,215,0,0.6);
    z-index: 1000;
    animation: combo-pop 0.8s ease-out forwards;
  `;
  comboDiv.textContent = text;
  document.body.appendChild(comboDiv);
  setTimeout(() => comboDiv.remove(), 800);
}

// --- äº¤æ¢å¤„ç† ---
async function handleSwap(from, to) {
  if (gameState.isAnimating) return;
  gameState.isAnimating = true;

  // æ£€æŸ¥æ˜¯å¦ç›¸é‚»
  const dr = Math.abs(from.row - to.row);
  const dc = Math.abs(from.col - to.col);
  if (!((dr === 1 && dc === 0) || (dr === 0 && dc === 1))) {
    gameState.isAnimating = false;
    return;
  }

  // æ£€æŸ¥æ˜¯å¦ä¸ºç‰¹æ®Šå—ç»„åˆ
  const tile1 = gameState.board[from.row][from.col].tile;
  const tile2 = gameState.board[to.row][to.col].tile;

  if (isSpecialTile(tile1) && isSpecialTile(tile2)) {
    const comboType = getSpecialComboType(tile1.specialType, tile2.specialType);
    if (comboType) {
      // æ‰§è¡Œäº¤æ¢åŠ¨ç”»
      await animateSwap(from, to);

      // æ¶ˆè€—æ­¥æ•°
      gameState.moves--;
      updateHUD();

      // è§¦å‘ç‰¹æ®Šç»„åˆæ•ˆæœ
      await triggerSpecialCombo(from, to, comboType);

      // ä¸‹è½å¡«å……
      await animateGravity();
      await animateFill();

      // ç»§ç»­å¤„ç†è¿é”æ¶ˆé™¤
      await resolveMatches();

      // æ›´æ–°ç‚¸å¼¹å€’è®¡æ—¶
      const bombExploded = updateBombTimers();
      if (bombExploded) {
        showMessage('ç‚¸å¼¹çˆ†ç‚¸!', 'å®šæ—¶ç‚¸å¼¹å¼•çˆ†äº†!', () => {
          tryStartLevel(gameState.level);
        });
        gameState.isAnimating = false;
        return;
      }

      render();
      checkEndCondition();
      gameState.isAnimating = false;
      return;
    }
  }

  // æ£€æŸ¥æ˜¯å¦æœ‰æ•ˆï¼ˆæ™®é€šäº¤æ¢ï¼‰
  const isValid = wouldSwapMatch(from, to);

  // æ‰§è¡Œäº¤æ¢åŠ¨ç”»
  await animateSwap(from, to);

  if (isValid) {
    // å®é™…äº¤æ¢
    const temp = gameState.board[from.row][from.col].tile;
    gameState.board[from.row][from.col].tile = gameState.board[to.row][to.col].tile;
    gameState.board[to.row][to.col].tile = temp;

    // æ¶ˆè€—æ­¥æ•°
    gameState.moves--;
    updateHUD();

    // å¤„ç†æ¶ˆé™¤
    await resolveMatches();

    // æ›´æ–°ç‚¸å¼¹å€’è®¡æ—¶
    const bombExploded = updateBombTimers();
    if (bombExploded) {
      showMessage('ç‚¸å¼¹çˆ†ç‚¸!', 'å®šæ—¶ç‚¸å¼¹å¼•çˆ†äº†!', () => {
        tryStartLevel(gameState.level);
      });
      gameState.isAnimating = false;
      return;
    }

    render();

    // æ£€æŸ¥èƒœåˆ©/å¤±è´¥
    checkEndCondition();
  } else {
    // æ— æ•ˆäº¤æ¢åŠ¨ç”»
    await animateSwap(to, from);
  }

  gameState.isAnimating = false;
}

// --- åŠ¨ç”» ---
async function animateSwap(from, to) {
  const duration = 150;
  const startTime = Date.now();

  while (Date.now() - startTime < duration) {
    const progress = (Date.now() - startTime) / duration;
    render(from, to, progress);
    await sleep(16);
  }
  render();
}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// --- æ¸²æŸ“ ---
function render(swapFrom, swapTo, swapProgress) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // èƒŒæ™¯
  ctx.fillStyle = 'rgba(255,255,255,0.1)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  const offsetX = (canvas.width - BOARD_SIZE * CELL_SIZE - (BOARD_SIZE - 1) * CELL_GAP) / 2;
  const offsetY = (canvas.height - BOARD_SIZE * CELL_SIZE - (BOARD_SIZE - 1) * CELL_GAP) / 2;

  for (let r = 0; r < BOARD_SIZE; r++) {
    for (let c = 0; c < BOARD_SIZE; c++) {
      let x = offsetX + c * (CELL_SIZE + CELL_GAP);
      let y = offsetY + r * (CELL_SIZE + CELL_GAP);

      // å¤„ç†äº¤æ¢åŠ¨ç”»
      if (swapFrom && swapTo && swapProgress !== undefined) {
        if (swapFrom.row === r && swapFrom.col === c) {
          const tx = offsetX + swapTo.col * (CELL_SIZE + CELL_GAP);
          const ty = offsetY + swapTo.row * (CELL_SIZE + CELL_GAP);
          x = x + (tx - x) * swapProgress;
          y = y + (ty - y) * swapProgress;
        } else if (swapTo.row === r && swapTo.col === c) {
          const fx = offsetX + swapFrom.col * (CELL_SIZE + CELL_GAP);
          const fy = offsetY + swapFrom.row * (CELL_SIZE + CELL_GAP);
          x = x + (fx - x) * swapProgress;
          y = y + (fy - y) * swapProgress;
        }
      }

      const cell = gameState.board[r][c];

      // æ ¼å­èƒŒæ™¯
      ctx.fillStyle = 'rgba(255,255,255,0.15)';
      ctx.beginPath();
      ctx.roundRect(x, y, CELL_SIZE, CELL_SIZE, 8);
      ctx.fill();

      // è‹”è—“
      if (cell.blocker?.type === 'moss') {
        ctx.fillStyle = 'rgba(100, 150, 100, 0.6)';
        ctx.beginPath();
        ctx.roundRect(x + 4, y + 4, CELL_SIZE - 8, CELL_SIZE - 8, 6);
        ctx.fill();
      }

      // é€‰ä¸­é«˜äº®
      if (gameState.selectedCell && gameState.selectedCell.row === r && gameState.selectedCell.col === c) {
        ctx.strokeStyle = '#FFD700';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.roundRect(x, y, CELL_SIZE, CELL_SIZE, 8);
        ctx.stroke();
      }

      // Tile
      if (cell.tile) {
        const tile = cell.tile;

        // å†°å†»æ•ˆæœèƒŒæ™¯
        if (tile.specialType === 'frozen' && tile.frozenLayers > 0) {
          ctx.fillStyle = 'rgba(0, 188, 212, 0.4)';
          ctx.beginPath();
          ctx.roundRect(x + 2, y + 2, CELL_SIZE - 4, CELL_SIZE - 4, 8);
          ctx.fill();

          // å†°å±‚è¾¹æ¡†
          ctx.strokeStyle = '#00BCD4';
          ctx.lineWidth = tile.frozenLayers;
          ctx.beginPath();
          ctx.roundRect(x + 2, y + 2, CELL_SIZE - 4, CELL_SIZE - 4, 8);
          ctx.stroke();
        }

        // ç‰¹æ®Šå—èƒŒæ™¯
        if (tile.isSpecial && tile.specialType !== 'frozen') {
          const color = SPECIAL_COLORS[tile.specialType];
          if (tile.specialType === 'rainbow') {
            // å½©è™¹æ¸å˜
            const gradient = ctx.createLinearGradient(x, y, x + CELL_SIZE, y + CELL_SIZE);
            gradient.addColorStop(0, '#FF0000');
            gradient.addColorStop(0.17, '#FF7F00');
            gradient.addColorStop(0.33, '#FFFF00');
            gradient.addColorStop(0.5, '#00FF00');
            gradient.addColorStop(0.67, '#0000FF');
            gradient.addColorStop(0.83, '#4B0082');
            gradient.addColorStop(1, '#9400D3');
            ctx.fillStyle = gradient;
          } else {
            ctx.fillStyle = color;
          }
          ctx.beginPath();
          ctx.arc(x + CELL_SIZE/2, y + CELL_SIZE/2, CELL_SIZE/2 - 4, 0, Math.PI * 2);
          ctx.fill();
        }

        // ç»˜åˆ¶ emoji
        ctx.font = '40px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(TILE_EMOJIS[tile.type], x + CELL_SIZE/2, y + CELL_SIZE/2 + 2);

        // ç‰¹æ®Šå—æ ‡è¯†
        if (tile.isSpecial) {
          ctx.font = '16px sans-serif';
          const icon = SPECIAL_ICONS[tile.specialType];

          if (tile.specialType === 'bomb_timer' && tile.bombTimer !== undefined) {
            // ç‚¸å¼¹æ˜¾ç¤ºå€’è®¡æ—¶æ•°å­—
            ctx.fillStyle = '#FFF';
            ctx.font = 'bold 18px sans-serif';
            ctx.fillText(tile.bombTimer.toString(), x + CELL_SIZE - 14, y + 16);
          } else if (tile.specialType === 'multiplier') {
            // å€æ•°å—æ˜¾ç¤ºå€æ•°
            ctx.fillStyle = '#333';
            ctx.font = 'bold 14px sans-serif';
            ctx.fillText(`Ã—${tile.multiplierValue || 2}`, x + CELL_SIZE - 16, y + 14);
          } else if (icon) {
            ctx.fillText(icon, x + CELL_SIZE - 12, y + 12);
          }
        }
      }
    }
  }
}

// --- UI æ›´æ–° ---
function updateHUD() {
  document.getElementById('levelNum').textContent = gameState.level;
  document.getElementById('movesLeft').textContent = gameState.moves;
  document.getElementById('energy').textContent = `${gameState.energy.current}/${gameState.energy.max}`;

  const goal = gameState.goal;
  if (goal.type === 'collect') {
    document.getElementById('goalText').textContent =
      `æ”¶é›† ${TILE_EMOJIS[goal.item]} ${gameState.goalProgress}/${goal.count}`;
  } else {
    document.getElementById('goalText').textContent =
      `æ¸…é™¤è‹”è—“ ${gameState.goalProgress}/${goal.count}`;
  }

  // æ­¥æ•°è­¦å‘Š
  const movesEl = document.getElementById('movesLeft');
  if (gameState.moves <= 3) {
    movesEl.style.color = '#ff6b6b';
  } else {
    movesEl.style.color = '#fff';
  }
}

function showMessage(title, content, onClose) {
  document.getElementById('msgTitle').textContent = title;
  document.getElementById('msgContent').textContent = content;
  document.getElementById('messageBox').style.display = 'block';
  document.getElementById('msgBtn').onclick = () => {
    hideMessage();
    if (onClose) onClose();
  };
}

function hideMessage() {
  document.getElementById('messageBox').style.display = 'none';
}

function showCombo(count) {
  const el = document.getElementById('comboText');
  el.textContent = `è¿æ¶ˆ x${count}!`;
  el.style.opacity = 1;
  setTimeout(() => { el.style.opacity = 0; }, 800);
}

function checkEndCondition() {
  const goal = gameState.goal;
  const isComplete = gameState.goalProgress >= goal.count;

  if (isComplete) {
    // è®¡ç®—æ˜Ÿçº§
    let stars = 1;
    if (gameState.moves >= 5) stars = 3;
    else if (gameState.moves >= 2) stars = 2;

    // ä¿å­˜è¿›åº¦
    const currentLevel = gameState.level;
    const config = getLevelConfig(currentLevel);
    const isBossLevel = config.isBossLevel || false;

    completeLevel(currentLevel, stars);

    // å‘æ”¾é€šå…³å¥–åŠ±
    const rewards = grantLevelClearReward(stars, isBossLevel);

    // æ£€æŸ¥é‡Œç¨‹ç¢‘å¥–åŠ±
    const milestones = checkAndGrantMilestoneRewards();

    gameState.level++;
    saveEnergyState();

    // æ›´æ–°æ–°æ‰‹æç¤ºæ˜¾ç¤º
    const newbieHint = document.getElementById('newbieHint');
    if (gameState.level <= ENERGY_CONFIG.newbieProtection) {
      newbieHint.style.display = 'block';
    } else {
      newbieHint.style.display = 'none';
    }

    // æ˜¾ç¤ºå¥–åŠ±å¼¹çª—
    const starsDisplay = 'â­'.repeat(stars) + 'â˜†'.repeat(3 - stars);

    // åˆå¹¶æ‰€æœ‰å¥–åŠ±ç”¨äºæ˜¾ç¤º
    const allRewards = { ...rewards };
    for (const milestone of milestones) {
      for (const [item, count] of Object.entries(milestone.rewards)) {
        allRewards[item] = (allRewards[item] || 0) + count;
      }
    }

    // å…ˆæ˜¾ç¤ºå¥–åŠ±å¼¹çª—
    if (Object.keys(allRewards).length > 0) {
      const title = milestones.length > 0
        ? `ğŸ é€šå…³å¥–åŠ± + é‡Œç¨‹ç¢‘ ${starsDisplay}`
        : `ğŸ é€šå…³å¥–åŠ± ${starsDisplay}`;
      showRewardPopup(title, allRewards);

      // ç­‰å¾…ç”¨æˆ·å…³é—­å¥–åŠ±å¼¹çª—åæ˜¾ç¤ºé€šå…³æ¶ˆæ¯
      document.getElementById('rewardCloseBtn').onclick = () => {
        hideRewardPopup();
        showMessage(`æ­å–œé€šå…³! ${starsDisplay}`, `å‰©ä½™ ${gameState.moves} æ­¥`, () => {
          tryStartLevel(gameState.level);
        });
      };
    } else {
      showMessage(`æ­å–œé€šå…³! ${starsDisplay}`, `å‰©ä½™ ${gameState.moves} æ­¥`, () => {
        tryStartLevel(gameState.level);
      });
    }
  } else if (gameState.moves <= 0) {
    // æ£€æŸ¥æ˜¯å¦å¯ä»¥çœ‹å¹¿å‘Šç»­å‘½
    const adBtn = document.getElementById('msgAdBtn');
    if (canUseContinueAd()) {
      adBtn.style.display = 'inline-block';
      adBtn.textContent = `ğŸ¬ çœ‹å¹¿å‘Š +${AD_CONFIG.extraMoves.reward}æ­¥`;
    } else {
      adBtn.style.display = 'none';
    }
    showMessage('æŒ‘æˆ˜å¤±è´¥', 'å†è¯•ä¸€æ¬¡?', () => {
      adBtn.style.display = 'none';
      tryStartLevel(gameState.level);
    });
  }
}

// --- è¾“å…¥å¤„ç† ---
let touchStart = null;

canvas.addEventListener('mousedown', (e) => {
  if (gameState.isAnimating) return;
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  const cell = positionToCell(x, y);
  if (cell) {
    // æ£€æŸ¥æ˜¯å¦æœ‰æ¿€æ´»çš„é“å…·éœ€è¦é€‰æ‹©ç›®æ ‡
    if (gameState.activeItem) {
      handleItemTargetSelect(cell);
      return;
    }
    if (gameState.selectedCell) {
      handleSwap(gameState.selectedCell, cell);
      gameState.selectedCell = null;
    } else {
      gameState.selectedCell = cell;
    }
    render();
  }
});

canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  if (gameState.isAnimating) return;
  const touch = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  touchStart = {
    x: touch.clientX - rect.left,
    y: touch.clientY - rect.top,
    cell: positionToCell(touch.clientX - rect.left, touch.clientY - rect.top)
  };
  if (touchStart.cell) {
    gameState.selectedCell = touchStart.cell;
    render();
  }
});

canvas.addEventListener('touchend', (e) => {
  e.preventDefault();
  if (!touchStart || !touchStart.cell || gameState.isAnimating) return;

  const touch = e.changedTouches[0];
  const rect = canvas.getBoundingClientRect();
  const endX = touch.clientX - rect.left;
  const endY = touch.clientY - rect.top;

  const dx = endX - touchStart.x;
  const dy = endY - touchStart.y;

  // æ£€æŸ¥æ˜¯å¦æœ‰æ¿€æ´»çš„é“å…·éœ€è¦é€‰æ‹©ç›®æ ‡ï¼ˆç‚¹å‡»æ¨¡å¼ï¼‰
  if (gameState.activeItem && Math.abs(dx) < 20 && Math.abs(dy) < 20) {
    handleItemTargetSelect(touchStart.cell);
    touchStart = null;
    return;
  }

  if (Math.abs(dx) > 20 || Math.abs(dy) > 20) {
    let targetCell;
    if (Math.abs(dx) > Math.abs(dy)) {
      targetCell = { row: touchStart.cell.row, col: touchStart.cell.col + (dx > 0 ? 1 : -1) };
    } else {
      targetCell = { row: touchStart.cell.row + (dy > 0 ? 1 : -1), col: touchStart.cell.col };
    }
    if (targetCell.row >= 0 && targetCell.row < BOARD_SIZE && targetCell.col >= 0 && targetCell.col < BOARD_SIZE) {
      handleSwap(touchStart.cell, targetCell);
    }
  }

  gameState.selectedCell = null;
  touchStart = null;
  render();
});

function positionToCell(x, y) {
  const offsetX = (canvas.width - BOARD_SIZE * CELL_SIZE - (BOARD_SIZE - 1) * CELL_GAP) / 2;
  const offsetY = (canvas.height - BOARD_SIZE * CELL_SIZE - (BOARD_SIZE - 1) * CELL_GAP) / 2;

  const col = Math.floor((x - offsetX) / (CELL_SIZE + CELL_GAP));
  const row = Math.floor((y - offsetY) / (CELL_SIZE + CELL_GAP));

  if (row >= 0 && row < BOARD_SIZE && col >= 0 && col < BOARD_SIZE) {
    return { row, col };
  }
  return null;
}

// --- æŒ‰é’®äº‹ä»¶ ---

// é“å…·æ ç‚¹å‡»äº‹ä»¶
document.querySelectorAll('.item-slot').forEach(slot => {
  slot.addEventListener('click', () => {
    const itemType = slot.dataset.item;
    if (itemType) {
      handleItemClick(itemType);
    }
  });
});

// å¥–åŠ±å¼¹çª—å…³é—­æŒ‰é’®
document.getElementById('rewardCloseBtn').addEventListener('click', () => {
  const callback = pendingRewardCallback;
  hideRewardPopup();
  if (callback) callback();
});

// åŒå€å¥–åŠ±æŒ‰é’®
document.getElementById('doubleRewardBtn').addEventListener('click', () => {
  const doubleBtn = document.getElementById('doubleRewardBtn');
  doubleBtn.textContent = 'æ’­æ”¾ä¸­...';
  doubleBtn.disabled = true;

  watchDoubleRewardAd(() => {
    // æ›´æ–°æ˜¾ç¤ºä¸ºåŒå€
    const itemsEl = document.getElementById('rewardItems');
    itemsEl.querySelectorAll('.amount').forEach(el => {
      const amount = parseInt(el.textContent.replace('+', ''));
      el.textContent = `+${amount * 2}`;
      el.style.color = '#FFD700';
    });
    document.getElementById('rewardTitle').textContent = 'ğŸ åŒå€å¥–åŠ±!';

    // éšè—åŒå€æŒ‰é’®
    doubleBtn.style.display = 'none';
    doubleBtn.textContent = 'ğŸ¬ åŒå€å¥–åŠ±';
    doubleBtn.disabled = false;
  });
});

document.getElementById('restartBtn').addEventListener('click', () => {
  tryStartLevel(gameState.level);
});

// "ä¸‹ä¸€å…³"æŒ‰é’®å·²ç§»é™¤ï¼Œé€šå…³åè‡ªåŠ¨è¿›å…¥ä¸‹ä¸€å…³

document.getElementById('backBtn').addEventListener('click', () => {
  window.location.href = 'level-select.html';
});

// ä½“åŠ›é—¨æ§›å¼¹çª—æŒ‰é’®
document.getElementById('watchAdBtn').addEventListener('click', () => {
  watchAdForEnergy();
  // å¹¿å‘Šçœ‹å®Œåå¦‚æœæœ‰ä½“åŠ›äº†ï¼Œè‡ªåŠ¨å…³é—­å¼¹çª—
  setTimeout(() => {
    if (gameState.energy.current > 0) {
      hideEnergyGate();
      tryStartLevel(gameState.level);
    }
  }, 2800);
});

document.getElementById('waitBtn').addEventListener('click', () => {
  hideEnergyGate();
});

// ç»­å‘½å¹¿å‘ŠæŒ‰é’®
document.getElementById('msgAdBtn').addEventListener('click', () => {
  watchContinueAd(() => {
    // å¹¿å‘Šè§‚çœ‹æˆåŠŸï¼Œå…³é—­å¤±è´¥å¼¹çª—ï¼Œç»§ç»­æ¸¸æˆ
    document.getElementById('msgOverlay').style.display = 'none';
    document.getElementById('msgAdBtn').style.display = 'none';
  });
});

// --- å¯åŠ¨æ¸¸æˆ ---
function startup() {
  // åŠ è½½å­˜æ¡£
  loadEnergyState();
  loadPlayerProgress();
  loadInventory();
  loadComboStats();
  loadAdState();

  // æ£€æŸ¥æ˜¯å¦ä»å…³å¡é€‰æ‹©ä¼ å…¥äº†å…³å¡
  const selectedLevel = sessionStorage.getItem('selectedLevel');
  if (selectedLevel) {
    gameState.level = parseInt(selectedLevel);
    sessionStorage.removeItem('selectedLevel');
  } else {
    // ä½¿ç”¨è¿›åº¦ä¸­çš„å½“å‰å…³å¡
    gameState.level = playerProgress.currentLevel || gameState.level;
  }

  // æ˜¾ç¤ºæ–°æ‰‹ä¿æŠ¤æç¤º
  const newbieHint = document.getElementById('newbieHint');
  if (gameState.level <= ENERGY_CONFIG.newbieProtection) {
    newbieHint.style.display = 'block';
  } else {
    newbieHint.style.display = 'none';
  }

  // å¯åŠ¨ä½“åŠ›æ¢å¤å®šæ—¶å™¨
  startEnergyTimer();

  // å¯åŠ¨é“å…·å†·å´æ—¶é—´å®šæ—¶å™¨
  startCooldownTimer();

  // æ›´æ–°é“å…·æ æ˜¾ç¤º
  updateItemBar();

  // å¼€å§‹æ¸¸æˆ
  tryStartLevel(gameState.level);
}

startup();
</script>
</body>
</html>
