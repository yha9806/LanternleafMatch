<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>ç¯ç¬¼å¶å­æ¶ˆæ¶ˆä¹ - Demo</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: linear-gradient(135deg, #2d5a27 0%, #1a3518 100%);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      color: #fff;
      overflow: hidden;
    }
    .header {
      padding: 20px;
      text-align: center;
      width: 100%;
      max-width: 600px;
    }
    .title {
      font-size: 28px;
      font-weight: bold;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
      margin-bottom: 10px;
    }
    .hud {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 20px;
      background: rgba(255,255,255,0.15);
      border-radius: 12px;
      margin-bottom: 15px;
    }
    .hud-item {
      text-align: center;
    }
    .hud-label {
      font-size: 12px;
      opacity: 0.8;
    }
    .hud-value {
      font-size: 24px;
      font-weight: bold;
    }
    .goal-box {
      background: rgba(255,255,255,0.1);
      padding: 8px 16px;
      border-radius: 8px;
      font-size: 14px;
    }
    #gameCanvas {
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
      touch-action: none;
    }
    .controls {
      margin-top: 20px;
      display: flex;
      gap: 12px;
    }
    .btn {
      padding: 12px 24px;
      font-size: 16px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      transition: transform 0.1s, box-shadow 0.1s;
    }
    .btn:active {
      transform: scale(0.95);
    }
    .btn-primary {
      background: linear-gradient(135deg, #ffd700, #ffb800);
      color: #333;
      box-shadow: 0 4px 12px rgba(255,215,0,0.4);
    }
    .btn-secondary {
      background: rgba(255,255,255,0.2);
      color: #fff;
    }
    .message {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.85);
      padding: 30px 50px;
      border-radius: 16px;
      text-align: center;
      display: none;
      z-index: 100;
    }
    .message h2 {
      font-size: 32px;
      margin-bottom: 15px;
    }
    .message p {
      font-size: 18px;
      opacity: 0.8;
      margin-bottom: 20px;
    }
    .energy-bar {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .energy-icon {
      font-size: 20px;
    }
    .combo-text {
      position: fixed;
      top: 40%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 48px;
      font-weight: bold;
      color: #ffd700;
      text-shadow: 0 0 20px rgba(255,215,0,0.8);
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
    }
    .energy-timer {
      font-size: 11px;
      opacity: 0.7;
      text-align: center;
    }
    .newbie-hint {
      background: linear-gradient(135deg, #4CAF50, #2E7D32);
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 12px;
      text-align: center;
      margin-top: 8px;
      animation: pulse 2s infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    .energy-gate {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.9);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 200;
    }
    .energy-gate-content {
      text-align: center;
      padding: 30px;
    }
    .energy-gate h2 {
      font-size: 28px;
      margin-bottom: 20px;
    }
    .energy-gate p {
      font-size: 16px;
      opacity: 0.8;
      margin-bottom: 10px;
    }
    .energy-gate .big-icon {
      font-size: 64px;
      margin-bottom: 20px;
    }
    .energy-gate .btn {
      margin: 10px;
      min-width: 150px;
    }
    .btn-ad {
      background: linear-gradient(135deg, #9C27B0, #7B1FA2);
      color: #fff;
      box-shadow: 0 4px 12px rgba(156,39,176,0.4);
    }
    .ad-remaining {
      font-size: 12px;
      opacity: 0.6;
      margin-top: 8px;
    }
  </style>
</head>
<body>
  <div class="header">
    <div class="title">ç¯ç¬¼å¶å­æ¶ˆæ¶ˆä¹</div>
    <div class="hud">
      <div class="hud-item">
        <div class="hud-label">å…³å¡</div>
        <div class="hud-value" id="levelNum">1</div>
      </div>
      <div class="goal-box" id="goalText">æ”¶é›† 8 ä¸ªå¶å­</div>
      <div class="hud-item">
        <div class="hud-label">æ­¥æ•°</div>
        <div class="hud-value" id="movesLeft">15</div>
      </div>
      <div class="hud-item energy-bar">
        <span class="energy-icon">âš¡</span>
        <div>
          <div class="hud-value" id="energy">5/5</div>
          <div class="energy-timer" id="energyTimer">å·²æ»¡</div>
        </div>
      </div>
    </div>
    <div class="newbie-hint" id="newbieHint" style="display:none;">
      ğŸ æ–°æ‰‹ä¿æŠ¤æœŸï¼šå‰10å…³ä¸æ¶ˆè€—ä½“åŠ›
    </div>
  </div>

  <canvas id="gameCanvas" width="540" height="540"></canvas>

  <div class="controls">
    <button class="btn btn-secondary" id="hintBtn">æç¤º</button>
    <button class="btn btn-primary" id="restartBtn">é‡æ–°å¼€å§‹</button>
    <button class="btn btn-secondary" id="nextBtn">ä¸‹ä¸€å…³</button>
  </div>

  <div class="message" id="messageBox">
    <h2 id="msgTitle">æ­å–œé€šå…³!</h2>
    <p id="msgContent">å‰©ä½™ 5 æ­¥</p>
    <button class="btn btn-primary" id="msgBtn">ç»§ç»­</button>
  </div>

  <div class="combo-text" id="comboText">è¿æ¶ˆ x2!</div>

  <!-- ä½“åŠ›ä¸è¶³å¼¹çª— -->
  <div class="energy-gate" id="energyGate" style="display:none;">
    <div class="energy-gate-content">
      <div class="big-icon">âš¡</div>
      <h2>ä½“åŠ›ä¸è¶³</h2>
      <p>å½“å‰ä½“åŠ›: <span id="gateEnergyCurrent">0</span>/<span id="gateEnergyMax">5</span></p>
      <p>ä¸‹æ¬¡æ¢å¤: <span id="gateEnergyTimer">--:--</span></p>
      <button class="btn btn-ad" id="watchAdBtn">ğŸ¬ çœ‹å¹¿å‘Š +1ä½“åŠ›</button>
      <div class="ad-remaining">ä»Šæ—¥å‰©ä½™: <span id="adRemaining">6</span> æ¬¡</div>
      <button class="btn btn-secondary" id="waitBtn">ç­‰å¾…æ¢å¤</button>
    </div>
  </div>

<script>
// ============================================
// ç¯ç¬¼å¶å­æ¶ˆæ¶ˆä¹ - Web Demo
// ============================================

// --- ç±»å‹å¸¸é‡ ---
const TILE_TYPES = ['leaf', 'acorn', 'star', 'fish', 'bone'];
const TILE_COLORS = {
  leaf: '#4CAF50',
  acorn: '#8B4513',
  star: '#FFD700',
  fish: '#2196F3',
  bone: '#F5F5DC'
};
const TILE_EMOJIS = {
  leaf: 'ğŸƒ',
  acorn: 'ğŸŒ°',
  star: 'â­',
  fish: 'ğŸŸ',
  bone: 'ğŸ¦´'
};
const SPECIAL_COLORS = {
  whirl_h: '#FF5722',
  whirl_v: '#FF5722',
  lantern: '#E91E63'
};

const BOARD_SIZE = 6;
const CELL_SIZE = 80;
const CELL_GAP = 10;
const PADDING = 10;  // æ£‹ç›˜è¾¹è·

// --- RNG (Mulberry32) ---
class RNG {
  constructor(seed) {
    this.state = seed >>> 0;
  }
  random() {
    let t = (this.state += 0x6d2b79f5);
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  }
  randInt(min, max) {
    return Math.floor(this.random() * (max - min + 1)) + min;
  }
  sample(array, k) {
    const result = [];
    const indices = new Set();
    const n = array.length;
    while (result.length < k && result.length < n) {
      const idx = this.randInt(0, n - 1);
      if (!indices.has(idx)) {
        indices.add(idx);
        result.push(array[idx]);
      }
    }
    return result;
  }
  shuffle(array) {
    const result = [...array];
    for (let i = result.length - 1; i > 0; i--) {
      const j = this.randInt(0, i);
      [result[i], result[j]] = [result[j], result[i]];
    }
    return result;
  }
  weightedChoice(items, weights) {
    const total = weights.reduce((a, b) => a + b, 0);
    let r = this.random() * total;
    for (let i = 0; i < items.length; i++) {
      r -= weights[i];
      if (r <= 0) return items[i];
    }
    return items[items.length - 1];
  }
}

// --- è‹”è—“æ¨¡å¼ ---
const MOSS_PATTERNS = {
  none: [],
  edge_ring: (() => {
    const cells = [];
    for (let c = 0; c < 6; c++) { cells.push({row: 0, col: c}); cells.push({row: 5, col: c}); }
    for (let r = 1; r < 5; r++) { cells.push({row: r, col: 0}); cells.push({row: r, col: 5}); }
    return cells;
  })(),
  corners: [
    {row:0,col:0},{row:0,col:1},{row:1,col:0},{row:1,col:1},
    {row:0,col:4},{row:0,col:5},{row:1,col:4},{row:1,col:5},
    {row:4,col:0},{row:4,col:1},{row:5,col:0},{row:5,col:1},
    {row:4,col:4},{row:4,col:5},{row:5,col:4},{row:5,col:5}
  ],
  center_blob: [
    {row:2,col:2},{row:2,col:3},{row:3,col:2},{row:3,col:3},
    {row:1,col:2},{row:1,col:3},{row:4,col:2},{row:4,col:3},
    {row:2,col:1},{row:3,col:1},{row:2,col:4},{row:3,col:4}
  ],
  diagonal: [
    {row:0,col:0},{row:1,col:1},{row:2,col:2},{row:3,col:3},{row:4,col:4},{row:5,col:5},
    {row:0,col:1},{row:1,col:2},{row:2,col:3},{row:3,col:4},{row:4,col:5}
  ]
};

// --- åŸºç¡€å…³å¡é…ç½® (å‰50å…³æ‰‹å·¥è®¾è®¡) ---
const BASE_LEVELS = [
  // ç¬¬1-10å…³ï¼šæ–°æ‰‹æœŸï¼ˆä¸æ‰£ä½“åŠ›ï¼‰
  { level: 1,  moves: 15, goal: 'collect', item: 'leaf',  count: 8,  pattern: 'none', density: 0 },
  { level: 2,  moves: 15, goal: 'collect', item: 'acorn', count: 8,  pattern: 'none', density: 0 },
  { level: 3,  moves: 14, goal: 'collect', item: 'star',  count: 10, pattern: 'none', density: 0 },
  { level: 4,  moves: 14, goal: 'collect', item: 'fish',  count: 10, pattern: 'none', density: 0 },
  { level: 5,  moves: 14, goal: 'collect', item: 'bone',  count: 10, pattern: 'corners', density: 0.2 },
  { level: 6,  moves: 13, goal: 'clear_moss', count: 4,   pattern: 'corners', density: 0.3 },
  { level: 7,  moves: 13, goal: 'collect', item: 'leaf',  count: 12, pattern: 'corners', density: 0.25 },
  { level: 8,  moves: 13, goal: 'clear_moss', count: 5,   pattern: 'edge_ring', density: 0.3 },
  { level: 9,  moves: 12, goal: 'collect', item: 'acorn', count: 12, pattern: 'edge_ring', density: 0.3 },
  { level: 10, moves: 12, goal: 'clear_moss', count: 6,   pattern: 'center_blob', density: 0.35 },

  // ç¬¬11-20å…³ï¼šå…¥é—¨æœŸ
  { level: 11, moves: 12, goal: 'collect', item: 'star',  count: 14, pattern: 'center_blob', density: 0.3 },
  { level: 12, moves: 12, goal: 'clear_moss', count: 7,   pattern: 'diagonal', density: 0.4 },
  { level: 13, moves: 11, goal: 'collect', item: 'fish',  count: 14, pattern: 'diagonal', density: 0.35 },
  { level: 14, moves: 11, goal: 'clear_moss', count: 8,   pattern: 'corners', density: 0.5 },
  { level: 15, moves: 11, goal: 'collect', item: 'bone',  count: 15, pattern: 'edge_ring', density: 0.4 },
  { level: 16, moves: 11, goal: 'clear_moss', count: 9,   pattern: 'center_blob', density: 0.5 },
  { level: 17, moves: 10, goal: 'collect', item: 'leaf',  count: 16, pattern: 'center_blob', density: 0.45 },
  { level: 18, moves: 10, goal: 'clear_moss', count: 10,  pattern: 'diagonal', density: 0.55 },
  { level: 19, moves: 10, goal: 'collect', item: 'acorn', count: 16, pattern: 'edge_ring', density: 0.5 },
  { level: 20, moves: 10, goal: 'clear_moss', count: 10,  pattern: 'corners', density: 0.6 },

  // ç¬¬21-30å…³ï¼šè¿›é˜¶æœŸ
  { level: 21, moves: 10, goal: 'collect', item: 'star',  count: 18, pattern: 'center_blob', density: 0.5 },
  { level: 22, moves: 10, goal: 'clear_moss', count: 11,  pattern: 'diagonal', density: 0.6 },
  { level: 23, moves: 9,  goal: 'collect', item: 'fish',  count: 16, pattern: 'edge_ring', density: 0.55 },
  { level: 24, moves: 9,  goal: 'clear_moss', count: 11,  pattern: 'center_blob', density: 0.65 },
  { level: 25, moves: 9,  goal: 'collect', item: 'bone',  count: 18, pattern: 'diagonal', density: 0.55 },
  { level: 26, moves: 9,  goal: 'clear_moss', count: 12,  pattern: 'corners', density: 0.7 },
  { level: 27, moves: 9,  goal: 'collect', item: 'leaf',  count: 20, pattern: 'center_blob', density: 0.6 },
  { level: 28, moves: 8,  goal: 'clear_moss', count: 12,  pattern: 'edge_ring', density: 0.7 },
  { level: 29, moves: 8,  goal: 'collect', item: 'acorn', count: 18, pattern: 'diagonal', density: 0.65 },
  { level: 30, moves: 8,  goal: 'clear_moss', count: 13,  pattern: 'center_blob', density: 0.75 },

  // ç¬¬31-40å…³ï¼šæŒ‘æˆ˜æœŸ
  { level: 31, moves: 8,  goal: 'collect', item: 'star',  count: 20, pattern: 'edge_ring', density: 0.65 },
  { level: 32, moves: 8,  goal: 'clear_moss', count: 13,  pattern: 'diagonal', density: 0.75 },
  { level: 33, moves: 8,  goal: 'collect', item: 'fish',  count: 20, pattern: 'center_blob', density: 0.7 },
  { level: 34, moves: 8,  goal: 'clear_moss', count: 14,  pattern: 'corners', density: 0.8 },
  { level: 35, moves: 7,  goal: 'collect', item: 'bone',  count: 18, pattern: 'diagonal', density: 0.7 },
  { level: 36, moves: 7,  goal: 'clear_moss', count: 14,  pattern: 'edge_ring', density: 0.8 },
  { level: 37, moves: 7,  goal: 'collect', item: 'leaf',  count: 22, pattern: 'center_blob', density: 0.75 },
  { level: 38, moves: 7,  goal: 'clear_moss', count: 15,  pattern: 'diagonal', density: 0.85 },
  { level: 39, moves: 7,  goal: 'collect', item: 'acorn', count: 22, pattern: 'edge_ring', density: 0.75 },
  { level: 40, moves: 7,  goal: 'clear_moss', count: 15,  pattern: 'center_blob', density: 0.85 },

  // ç¬¬41-50å…³ï¼šå¤§å¸ˆæœŸ
  { level: 41, moves: 7,  goal: 'collect', item: 'star',  count: 24, pattern: 'diagonal', density: 0.8 },
  { level: 42, moves: 6,  goal: 'clear_moss', count: 14,  pattern: 'corners', density: 0.9 },
  { level: 43, moves: 6,  goal: 'collect', item: 'fish',  count: 22, pattern: 'center_blob', density: 0.85 },
  { level: 44, moves: 6,  goal: 'clear_moss', count: 15,  pattern: 'edge_ring', density: 0.9 },
  { level: 45, moves: 6,  goal: 'collect', item: 'bone',  count: 24, pattern: 'diagonal', density: 0.85 },
  { level: 46, moves: 6,  goal: 'clear_moss', count: 16,  pattern: 'center_blob', density: 0.95 },
  { level: 47, moves: 6,  goal: 'collect', item: 'leaf',  count: 26, pattern: 'edge_ring', density: 0.9 },
  { level: 48, moves: 5,  goal: 'clear_moss', count: 15,  pattern: 'diagonal', density: 0.95 },
  { level: 49, moves: 5,  goal: 'collect', item: 'acorn', count: 24, pattern: 'center_blob', density: 0.9 },
  { level: 50, moves: 5,  goal: 'clear_moss', count: 16,  pattern: 'edge_ring', density: 1.0 }
];

// --- æ— é™å…³å¡ç”Ÿæˆå™¨ ---
const PATTERN_POOL = ['corners', 'edge_ring', 'center_blob', 'diagonal'];

function generateInfiniteLevel(levelIndex) {
  // ä½¿ç”¨å…³å¡å·ä½œä¸ºç§å­ï¼Œä¿è¯æ¯æ¬¡ç”Ÿæˆç›¸åŒçš„å…³å¡
  const seed = levelIndex * 31337;
  const rng = new RNG(seed);

  // è®¡ç®—éš¾åº¦ç³»æ•° (50å…³åé€æ¸å¢åŠ ï¼Œæœ€ç»ˆè¶‹äºç¨³å®š)
  const difficultyOffset = levelIndex - 50;
  const difficultyFactor = Math.min(1 + difficultyOffset * 0.02, 2.0); // æœ€é«˜2å€éš¾åº¦

  // æ³¢åŠ¨å‘¨æœŸï¼šæ¯10å…³ä¸€ä¸ªå°å‘¨æœŸï¼Œæœ‰æ—¶ç®€å•æœ‰æ—¶éš¾
  const waveFactor = 0.8 + 0.4 * Math.sin(levelIndex * 0.3);

  // æ­¥æ•°ï¼šåŸºç¡€5æ­¥ï¼Œæ ¹æ®éš¾åº¦å’Œæ³¢åŠ¨è°ƒæ•´ (4-8æ­¥)
  const baseMovesVariation = rng.randInt(-1, 2);
  const moves = Math.max(4, Math.min(8, 5 + baseMovesVariation + Math.floor((1 - waveFactor) * 2)));

  // ç›®æ ‡ç±»å‹ï¼šäº¤æ›¿æ”¶é›†å’Œæ¸…è‹”è—“ï¼Œå¶å°”å‡ºcombo
  let goal, item, count;
  const goalRoll = rng.random();
  if (goalRoll < 0.5) {
    goal = 'collect';
    item = TILE_TYPES[rng.randInt(0, TILE_TYPES.length - 1)];
    // æ”¶é›†æ•°é‡ï¼šåŸºç¡€20ï¼Œæ ¹æ®éš¾åº¦å¢åŠ 
    count = Math.floor(20 + difficultyOffset * 0.3 * waveFactor);
    count = Math.min(count, 35); // ä¸Šé™35
  } else {
    goal = 'clear_moss';
    item = null;
    // è‹”è—“æ•°é‡ç”± density æ§åˆ¶ï¼Œè¿™é‡Œ count ç”¨äºè®°å½•ç›®æ ‡
    count = 0; // clear_moss æ¨¡å¼ä¸‹æ¸…é™¤æ‰€æœ‰è‹”è—“
  }

  // è‹”è—“ pattern éšæœºé€‰æ‹©
  const pattern = PATTERN_POOL[rng.randInt(0, PATTERN_POOL.length - 1)];

  // è‹”è—“å¯†åº¦ï¼šåŸºç¡€0.6ï¼Œæ ¹æ®éš¾åº¦å¢åŠ ï¼Œæœ‰æ³¢åŠ¨
  let density = 0.6 + difficultyOffset * 0.01 * waveFactor;
  density = Math.min(density, 0.95); // ä¸Šé™95%

  // ç‰¹æ®Šå…³å¡æ ‡è®°ï¼ˆæ¯25å…³ä¸€ä¸ªbosså…³ï¼‰
  const isBossLevel = levelIndex % 25 === 0;
  if (isBossLevel) {
    // Bosså…³ï¼šæ›´éš¾
    count = goal === 'collect' ? Math.min(count + 5, 35) : count;
    density = Math.min(density + 0.1, 0.98);
  }

  return {
    level: levelIndex,
    moves,
    goal,
    item,
    count,
    pattern,
    density,
    isBossLevel
  };
}

// è·å–å…³å¡é…ç½®ï¼ˆæ”¯æŒæ— é™å…³å¡ï¼‰
function getLevelConfig(levelIndex) {
  if (levelIndex <= BASE_LEVELS.length) {
    return BASE_LEVELS[levelIndex - 1];
  }
  return generateInfiniteLevel(levelIndex);
}

// å…¼å®¹æ—§ä»£ç çš„ LEVELS æ•°ç»„è®¿é—®
const LEVELS = new Proxy(BASE_LEVELS, {
  get(target, prop) {
    if (prop === 'length') return Infinity;
    const index = parseInt(prop);
    if (!isNaN(index)) {
      return getLevelConfig(index + 1);
    }
    return target[prop];
  }
});

// --- ä½“åŠ›ç³»ç»Ÿé…ç½® ---
const ENERGY_CONFIG = {
  max: 5,
  regenSeconds: 20 * 60,  // 20åˆ†é’Ÿæ¢å¤1ç‚¹
  adReward: 1,
  adHourlyCap: 6,
  newbieProtection: 10    // å‰10å…³ä¸æ‰£ä½“åŠ›
};

// --- æ¸¸æˆçŠ¶æ€ ---
let gameState = {
  board: [],
  level: 1,
  moves: 15,
  goal: null,
  goalProgress: 0,
  energy: {
    current: 5,
    max: 5,
    lastRegenTime: Date.now(),
    adWatchedThisHour: 0,
    adHourStart: Date.now()
  },
  selectedCell: null,
  isAnimating: false,
  rng: null
};

// --- ä½“åŠ›ç³»ç»Ÿå‡½æ•° ---
function loadEnergyState() {
  try {
    const saved = localStorage.getItem('lanternleaf_energy');
    if (saved) {
      const data = JSON.parse(saved);
      gameState.energy.current = data.current;
      gameState.energy.lastRegenTime = data.lastRegenTime;
      gameState.energy.adWatchedThisHour = data.adWatchedThisHour || 0;
      gameState.energy.adHourStart = data.adHourStart || Date.now();

      // è®¡ç®—ç¦»çº¿æœŸé—´æ¢å¤çš„ä½“åŠ›
      const now = Date.now();
      const elapsed = now - gameState.energy.lastRegenTime;
      const regenPoints = Math.floor(elapsed / (ENERGY_CONFIG.regenSeconds * 1000));
      if (regenPoints > 0) {
        gameState.energy.current = Math.min(
          gameState.energy.max,
          gameState.energy.current + regenPoints
        );
        gameState.energy.lastRegenTime = now;
      }

      // é‡ç½®æ¯å°æ—¶å¹¿å‘Šè®¡æ•°
      if (now - gameState.energy.adHourStart > 3600000) {
        gameState.energy.adWatchedThisHour = 0;
        gameState.energy.adHourStart = now;
      }
    }
    // åŒæ—¶åŠ è½½å…³å¡è¿›åº¦
    const levelSaved = localStorage.getItem('lanternleaf_level');
    if (levelSaved) {
      gameState.level = parseInt(levelSaved) || 1;
    }
  } catch (e) {
    console.log('Failed to load energy state:', e);
  }
}

function saveEnergyState() {
  try {
    localStorage.setItem('lanternleaf_energy', JSON.stringify({
      current: gameState.energy.current,
      lastRegenTime: gameState.energy.lastRegenTime,
      adWatchedThisHour: gameState.energy.adWatchedThisHour,
      adHourStart: gameState.energy.adHourStart
    }));
    localStorage.setItem('lanternleaf_level', gameState.level.toString());
  } catch (e) {
    console.log('Failed to save energy state:', e);
  }
}

function consumeEnergy() {
  // æ–°æ‰‹ä¿æŠ¤ï¼šå‰Nå…³ä¸æ‰£ä½“åŠ›
  if (gameState.level <= ENERGY_CONFIG.newbieProtection) {
    return true;
  }

  if (gameState.energy.current <= 0) {
    return false;
  }

  gameState.energy.current--;
  if (gameState.energy.current < gameState.energy.max &&
      gameState.energy.lastRegenTime === 0) {
    gameState.energy.lastRegenTime = Date.now();
  }
  saveEnergyState();
  return true;
}

function getRegenTimeRemaining() {
  if (gameState.energy.current >= gameState.energy.max) {
    return 0;
  }
  const elapsed = Date.now() - gameState.energy.lastRegenTime;
  const remaining = (ENERGY_CONFIG.regenSeconds * 1000) - elapsed;
  return Math.max(0, remaining);
}

function formatTime(ms) {
  const totalSeconds = Math.ceil(ms / 1000);
  const minutes = Math.floor(totalSeconds / 60);
  const seconds = totalSeconds % 60;
  return `${minutes}:${seconds.toString().padStart(2, '0')}`;
}

function canWatchAd() {
  // æ£€æŸ¥æ¯å°æ—¶å¹¿å‘Šä¸Šé™
  const now = Date.now();
  if (now - gameState.energy.adHourStart > 3600000) {
    gameState.energy.adWatchedThisHour = 0;
    gameState.energy.adHourStart = now;
  }
  return gameState.energy.adWatchedThisHour < ENERGY_CONFIG.adHourlyCap &&
         gameState.energy.current < gameState.energy.max;
}

function watchAdForEnergy() {
  if (!canWatchAd()) {
    showMessage('æç¤º', 'å·²è¾¾åˆ°æ¯å°æ—¶è§‚çœ‹ä¸Šé™', () => {});
    setTimeout(hideMessage, 1500);
    return;
  }

  // æ¨¡æ‹Ÿå¹¿å‘Šè§‚çœ‹ï¼ˆå®é™…æ¥å…¥æ—¶æ›¿æ¢ï¼‰
  showMessage('è§‚çœ‹å¹¿å‘Š', 'æ¨¡æ‹Ÿå¹¿å‘Šæ’­æ”¾ä¸­...', null);
  setTimeout(() => {
    gameState.energy.current = Math.min(
      gameState.energy.max,
      gameState.energy.current + ENERGY_CONFIG.adReward
    );
    gameState.energy.adWatchedThisHour++;
    gameState.energy.lastRegenTime = Date.now();
    saveEnergyState();
    updateHUD();
    hideMessage();
    showMessage('è·å¾—ä½“åŠ›', `+${ENERGY_CONFIG.adReward} ä½“åŠ›`, () => {});
    setTimeout(hideMessage, 1000);
  }, 1500);
}

// ä½“åŠ›æ¢å¤å®šæ—¶å™¨
let energyTimer = null;
function startEnergyTimer() {
  if (energyTimer) clearInterval(energyTimer);
  energyTimer = setInterval(() => {
    if (gameState.energy.current < gameState.energy.max) {
      const elapsed = Date.now() - gameState.energy.lastRegenTime;
      if (elapsed >= ENERGY_CONFIG.regenSeconds * 1000) {
        gameState.energy.current++;
        gameState.energy.lastRegenTime = Date.now();
        saveEnergyState();
      }
    }
    updateEnergyDisplay();
  }, 1000);
}

function updateEnergyDisplay() {
  const energyEl = document.getElementById('energy');
  const timerEl = document.getElementById('energyTimer');

  energyEl.textContent = `${gameState.energy.current}/${gameState.energy.max}`;

  if (gameState.energy.current < gameState.energy.max) {
    const remaining = getRegenTimeRemaining();
    if (timerEl) timerEl.textContent = formatTime(remaining);
  } else {
    if (timerEl) timerEl.textContent = 'å·²æ»¡';
  }

  // æ›´æ–°ä½“åŠ›é—¨æ§›å¼¹çª—ä¸­çš„æ˜¾ç¤º
  const gateCurrent = document.getElementById('gateEnergyCurrent');
  const gateMax = document.getElementById('gateEnergyMax');
  const gateTimer = document.getElementById('gateEnergyTimer');
  const adRemaining = document.getElementById('adRemaining');

  if (gateCurrent) gateCurrent.textContent = gameState.energy.current;
  if (gateMax) gateMax.textContent = gameState.energy.max;
  if (gateTimer) {
    const remaining = getRegenTimeRemaining();
    gateTimer.textContent = remaining > 0 ? formatTime(remaining) : 'å·²æ»¡';
  }
  if (adRemaining) {
    adRemaining.textContent = ENERGY_CONFIG.adHourlyCap - gameState.energy.adWatchedThisHour;
  }
}

function showEnergyGate() {
  updateEnergyDisplay();
  document.getElementById('energyGate').style.display = 'flex';
}

function hideEnergyGate() {
  document.getElementById('energyGate').style.display = 'none';
}

function tryStartLevel(levelIndex) {
  // æ–°æ‰‹ä¿æŠ¤æœŸä¸æ£€æŸ¥ä½“åŠ›
  if (levelIndex <= ENERGY_CONFIG.newbieProtection) {
    initGame(levelIndex);
    return;
  }

  // æ£€æŸ¥ä½“åŠ›
  if (gameState.energy.current <= 0) {
    showEnergyGate();
    return;
  }

  // æ¶ˆè€—ä½“åŠ›å¹¶å¼€å§‹æ¸¸æˆ
  if (consumeEnergy()) {
    initGame(levelIndex);
  } else {
    showEnergyGate();
  }
}

// --- Canvas ç›¸å…³ ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// --- åˆå§‹åŒ–æ¸¸æˆ ---
function initGame(levelIndex) {
  const config = getLevelConfig(levelIndex);
  gameState.level = levelIndex;
  gameState.moves = config.moves;

  // Boss å…³å¡ç‰¹æ®Šæ ‡è®°
  if (config.isBossLevel) {
    document.querySelector('.title').textContent = `ğŸ”¥ BOSS ç¬¬${levelIndex}å…³ ğŸ”¥`;
  } else {
    document.querySelector('.title').textContent = 'ç¯ç¬¼å¶å­æ¶ˆæ¶ˆä¹';
  }
  gameState.goalProgress = 0;
  gameState.selectedCell = null;
  gameState.isAnimating = false;
  gameState.rng = new RNG(Date.now() + levelIndex * 1000);

  // è®¾ç½®ç›®æ ‡
  if (config.goal === 'collect') {
    gameState.goal = { type: 'collect', item: config.item, count: config.count };
  } else {
    gameState.goal = { type: 'clear_moss', count: config.count };
  }

  // ç”Ÿæˆè‹”è—“
  const patternCells = MOSS_PATTERNS[config.pattern] || [];
  const mossCount = Math.round(patternCells.length * config.density);
  const mossCells = gameState.rng.sample(patternCells, mossCount);
  const mossSet = new Set(mossCells.map(c => `${c.row},${c.col}`));

  // ç”Ÿæˆæ£‹ç›˜
  gameState.board = [];
  for (let r = 0; r < BOARD_SIZE; r++) {
    const row = [];
    for (let c = 0; c < BOARD_SIZE; c++) {
      row.push({
        tile: { type: randomTileType(), isSpecial: false },
        blocker: mossSet.has(`${r},${c}`) ? { type: 'moss', layer: 1 } : null
      });
    }
    gameState.board.push(row);
  }

  // ç§»é™¤åˆå§‹åŒ¹é…
  removeInitialMatches();

  // ç¡®ä¿æœ‰æœ‰æ•ˆç§»åŠ¨
  if (!hasValidMove()) {
    shuffleBoard();
  }

  // æ›´æ–° UI
  updateHUD();
  render();
}

function randomTileType() {
  return TILE_TYPES[gameState.rng.randInt(0, TILE_TYPES.length - 1)];
}

function removeInitialMatches() {
  let matches = findAllMatches();
  let iterations = 0;
  while (matches.length > 0 && iterations < 100) {
    for (const match of matches) {
      const cell = match.cells[Math.floor(match.cells.length / 2)];
      const oldType = gameState.board[cell.row][cell.col].tile.type;
      const otherTypes = TILE_TYPES.filter(t => t !== oldType);
      gameState.board[cell.row][cell.col].tile.type = otherTypes[gameState.rng.randInt(0, otherTypes.length - 1)];
    }
    matches = findAllMatches();
    iterations++;
  }
}

// --- åŒ¹é…æ£€æµ‹ ---
function findAllMatches() {
  const matches = [];

  // æ°´å¹³
  for (let r = 0; r < BOARD_SIZE; r++) {
    let c = 0;
    while (c < BOARD_SIZE) {
      const tile = gameState.board[r][c].tile;
      if (!tile) { c++; continue; }
      const type = tile.type;
      let len = 1;
      while (c + len < BOARD_SIZE && gameState.board[r][c + len].tile?.type === type) {
        len++;
      }
      if (len >= 3) {
        const cells = [];
        for (let i = 0; i < len; i++) cells.push({row: r, col: c + i});
        matches.push({ cells, type, length: len, isHorizontal: true });
      }
      c += len;
    }
  }

  // å‚ç›´
  for (let c = 0; c < BOARD_SIZE; c++) {
    let r = 0;
    while (r < BOARD_SIZE) {
      const tile = gameState.board[r][c].tile;
      if (!tile) { r++; continue; }
      const type = tile.type;
      let len = 1;
      while (r + len < BOARD_SIZE && gameState.board[r + len][c].tile?.type === type) {
        len++;
      }
      if (len >= 3) {
        const cells = [];
        for (let i = 0; i < len; i++) cells.push({row: r + i, col: c});
        matches.push({ cells, type, length: len, isHorizontal: false });
      }
      r += len;
    }
  }

  return matches;
}

function wouldSwapMatch(from, to) {
  // æ¨¡æ‹Ÿäº¤æ¢
  const tempTile = gameState.board[from.row][from.col].tile;
  gameState.board[from.row][from.col].tile = gameState.board[to.row][to.col].tile;
  gameState.board[to.row][to.col].tile = tempTile;

  const hasMatch = hasMatchAt(from) || hasMatchAt(to);

  // æ¢å›
  gameState.board[to.row][to.col].tile = gameState.board[from.row][from.col].tile;
  gameState.board[from.row][from.col].tile = tempTile;

  return hasMatch;
}

function hasMatchAt(cell) {
  const tile = gameState.board[cell.row][cell.col].tile;
  if (!tile) return false;
  const type = tile.type;

  // æ°´å¹³
  let hCount = 1;
  for (let c = cell.col - 1; c >= 0 && gameState.board[cell.row][c].tile?.type === type; c--) hCount++;
  for (let c = cell.col + 1; c < BOARD_SIZE && gameState.board[cell.row][c].tile?.type === type; c++) hCount++;
  if (hCount >= 3) return true;

  // å‚ç›´
  let vCount = 1;
  for (let r = cell.row - 1; r >= 0 && gameState.board[r][cell.col].tile?.type === type; r--) vCount++;
  for (let r = cell.row + 1; r < BOARD_SIZE && gameState.board[r][cell.col].tile?.type === type; r++) vCount++;
  return vCount >= 3;
}

function hasValidMove() {
  for (let r = 0; r < BOARD_SIZE; r++) {
    for (let c = 0; c < BOARD_SIZE; c++) {
      if (c < BOARD_SIZE - 1 && wouldSwapMatch({row: r, col: c}, {row: r, col: c + 1})) return true;
      if (r < BOARD_SIZE - 1 && wouldSwapMatch({row: r, col: c}, {row: r + 1, col: c})) return true;
    }
  }
  return false;
}

function getValidMove() {
  for (let r = 0; r < BOARD_SIZE; r++) {
    for (let c = 0; c < BOARD_SIZE; c++) {
      if (c < BOARD_SIZE - 1 && wouldSwapMatch({row: r, col: c}, {row: r, col: c + 1})) {
        return { from: {row: r, col: c}, to: {row: r, col: c + 1} };
      }
      if (r < BOARD_SIZE - 1 && wouldSwapMatch({row: r, col: c}, {row: r + 1, col: c})) {
        return { from: {row: r, col: c}, to: {row: r + 1, col: c} };
      }
    }
  }
  return null;
}

function shuffleBoard() {
  const tiles = [];
  for (let r = 0; r < BOARD_SIZE; r++) {
    for (let c = 0; c < BOARD_SIZE; c++) {
      if (gameState.board[r][c].tile) {
        tiles.push(gameState.board[r][c].tile);
      }
    }
  }
  const shuffled = gameState.rng.shuffle(tiles);
  let idx = 0;
  for (let r = 0; r < BOARD_SIZE; r++) {
    for (let c = 0; c < BOARD_SIZE; c++) {
      if (gameState.board[r][c].tile) {
        gameState.board[r][c].tile = shuffled[idx++];
      }
    }
  }
  removeInitialMatches();
  showMessage('æ´—ç‰Œ', 'æ£‹ç›˜å·²åˆ·æ–°', () => {});
  setTimeout(() => hideMessage(), 800);
}

// --- ç‰¹æ®Šå—è§¦å‘æ•ˆæœ ---
function triggerSpecialTile(cell, clearedCells, totalCollected, triggeredSpecials) {
  const tile = gameState.board[cell.row][cell.col].tile;
  if (!tile?.isSpecial) return { collected: {}, mossCleared: 0 };

  const key = `${cell.row},${cell.col}`;
  if (triggeredSpecials.has(key)) return { collected: {}, mossCleared: 0 };
  triggeredSpecials.add(key);

  const affectedCells = [];

  switch (tile.specialType) {
    case 'whirl_h': // æ¸…é™¤æ•´è¡Œ
      for (let c = 0; c < BOARD_SIZE; c++) {
        affectedCells.push({ row: cell.row, col: c });
      }
      break;

    case 'whirl_v': // æ¸…é™¤æ•´åˆ—
      for (let r = 0; r < BOARD_SIZE; r++) {
        affectedCells.push({ row: r, col: cell.col });
      }
      break;

    case 'lantern': // æ¸…é™¤ 3x3 åŒºåŸŸ
      for (let dr = -1; dr <= 1; dr++) {
        for (let dc = -1; dc <= 1; dc++) {
          const r = cell.row + dr;
          const c = cell.col + dc;
          if (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE) {
            affectedCells.push({ row: r, col: c });
          }
        }
      }
      break;
  }

  let mossCleared = 0;
  const collected = {};

  // æ¸…é™¤å—å½±å“çš„æ ¼å­
  for (const c of affectedCells) {
    const cellKey = `${c.row},${c.col}`;
    if (clearedCells.has(cellKey)) continue;
    clearedCells.add(cellKey);

    const boardCell = gameState.board[c.row][c.col];

    // ç»Ÿè®¡æ”¶é›†
    if (boardCell.tile) {
      collected[boardCell.tile.type] = (collected[boardCell.tile.type] || 0) + 1;

      // è¿é”è§¦å‘å…¶ä»–ç‰¹æ®Šå—
      if (boardCell.tile.isSpecial && cellKey !== key) {
        const chainResult = triggerSpecialTile(c, clearedCells, totalCollected, triggeredSpecials);
        for (const [t, n] of Object.entries(chainResult.collected)) {
          collected[t] = (collected[t] || 0) + n;
        }
        mossCleared += chainResult.mossCleared;
      }
    }

    // å¤„ç†è‹”è—“
    if (boardCell.blocker?.type === 'moss') {
      boardCell.blocker.layer--;
      if (boardCell.blocker.layer <= 0) {
        boardCell.blocker = null;
        mossCleared++;
      }
    }

    // æ¸…é™¤ tile
    boardCell.tile = null;
  }

  return { collected, mossCleared };
}

// --- æ¶ˆé™¤å¤„ç† ---
async function resolveMatches() {
  let cascadeCount = 0;
  let totalCollected = {};
  let totalMossCleared = 0;

  while (true) {
    const matches = findAllMatches();
    if (matches.length === 0) break;

    cascadeCount++;
    if (cascadeCount > 1) {
      showCombo(cascadeCount);
    }

    // å¤„ç†æ¯ä¸ªåŒ¹é…
    const clearedCells = new Set();
    const triggeredSpecials = new Set();
    const specialsToCreate = [];  // å»¶è¿Ÿåˆ›å»ºç‰¹æ®Šå—

    for (const match of matches) {
      // æ”¶é›†ç»Ÿè®¡
      totalCollected[match.type] = (totalCollected[match.type] || 0) + match.cells.length;

      // ç¡®å®šç‰¹æ®Šå—ä½ç½®
      const centerIdx = Math.floor(match.cells.length / 2);
      const centerCell = match.cells[centerIdx];

      for (let i = 0; i < match.cells.length; i++) {
        const cell = match.cells[i];
        const key = `${cell.row},${cell.col}`;
        if (clearedCells.has(key)) continue;

        const boardCell = gameState.board[cell.row][cell.col];

        // æ£€æŸ¥æ˜¯å¦æ˜¯ç‰¹æ®Šå—ï¼Œè§¦å‘æ•ˆæœ
        if (boardCell.tile?.isSpecial) {
          const result = triggerSpecialTile(cell, clearedCells, totalCollected, triggeredSpecials);
          for (const [t, n] of Object.entries(result.collected)) {
            totalCollected[t] = (totalCollected[t] || 0) + n;
          }
          totalMossCleared += result.mossCleared;
          continue;  // ç‰¹æ®Šå—å·²è¢«è§¦å‘å¤„ç†
        }

        clearedCells.add(key);

        // å¤„ç†è‹”è—“
        if (boardCell.blocker?.type === 'moss') {
          boardCell.blocker.layer--;
          if (boardCell.blocker.layer <= 0) {
            boardCell.blocker = null;
            totalMossCleared++;
          }
        }

        // æ¸…é™¤ tileï¼ˆç‰¹æ®Šå—ä½ç½®é™¤å¤–ï¼‰
        if (i !== centerIdx || match.length < 4) {
          boardCell.tile = null;
        }
      }

      // è®°å½•éœ€è¦ç”Ÿæˆçš„ç‰¹æ®Šå—
      if (match.length >= 4) {
        let specialType;
        if (match.length >= 5) {
          specialType = 'lantern';
        } else {
          specialType = match.isHorizontal ? 'whirl_h' : 'whirl_v';
        }
        specialsToCreate.push({
          cell: centerCell,
          type: match.type,
          specialType
        });
      }
    }

    // åˆ›å»ºç‰¹æ®Šå—
    for (const special of specialsToCreate) {
      gameState.board[special.cell.row][special.cell.col].tile = {
        type: special.type,
        isSpecial: true,
        specialType: special.specialType
      };
    }

    render();
    await sleep(150);

    // ä¸‹è½ï¼ˆå¸¦åŠ¨ç”»ï¼‰
    await animateGravity();

    // å¡«å……ï¼ˆå¸¦åŠ¨ç”»ï¼‰
    await animateFill();
  }

  // æ›´æ–°ç›®æ ‡è¿›åº¦
  if (gameState.goal.type === 'collect') {
    gameState.goalProgress += totalCollected[gameState.goal.item] || 0;
  } else {
    gameState.goalProgress += totalMossCleared;
  }

  updateHUD();

  // æ£€æŸ¥æ­»å±€
  if (!hasValidMove()) {
    shuffleBoard();
    render();
  }
}

function applyGravity() {
  for (let c = 0; c < BOARD_SIZE; c++) {
    let writeRow = BOARD_SIZE - 1;
    for (let r = BOARD_SIZE - 1; r >= 0; r--) {
      if (gameState.board[r][c].tile !== null) {
        if (r !== writeRow) {
          gameState.board[writeRow][c].tile = gameState.board[r][c].tile;
          gameState.board[r][c].tile = null;
        }
        writeRow--;
      }
    }
  }
}

function fillEmpty() {
  for (let c = 0; c < BOARD_SIZE; c++) {
    for (let r = 0; r < BOARD_SIZE; r++) {
      if (gameState.board[r][c].tile === null) {
        gameState.board[r][c].tile = { type: randomTileType(), isSpecial: false };
      }
    }
  }
}

// --- ç®€åŒ–çš„å è½åŠ¨ç”» ---
async function animateGravity() {
  // ç›´æ¥åº”ç”¨é‡åŠ›å¹¶æ¸²æŸ“
  applyGravity();
  render();
  await sleep(80);
}

// --- ç®€åŒ–çš„å¡«å……åŠ¨ç”» ---
async function animateFill() {
  // ç›´æ¥å¡«å……å¹¶æ¸²æŸ“
  fillEmpty();
  render();
  await sleep(80);
}

// --- äº¤æ¢å¤„ç† ---
async function handleSwap(from, to) {
  if (gameState.isAnimating) return;
  gameState.isAnimating = true;

  // æ£€æŸ¥æ˜¯å¦ç›¸é‚»
  const dr = Math.abs(from.row - to.row);
  const dc = Math.abs(from.col - to.col);
  if (!((dr === 1 && dc === 0) || (dr === 0 && dc === 1))) {
    gameState.isAnimating = false;
    return;
  }

  // æ£€æŸ¥æ˜¯å¦æœ‰æ•ˆ
  const isValid = wouldSwapMatch(from, to);

  // æ‰§è¡Œäº¤æ¢åŠ¨ç”»
  await animateSwap(from, to);

  if (isValid) {
    // å®é™…äº¤æ¢
    const temp = gameState.board[from.row][from.col].tile;
    gameState.board[from.row][from.col].tile = gameState.board[to.row][to.col].tile;
    gameState.board[to.row][to.col].tile = temp;

    // æ¶ˆè€—æ­¥æ•°
    gameState.moves--;
    updateHUD();

    // å¤„ç†æ¶ˆé™¤
    await resolveMatches();

    // æ£€æŸ¥èƒœåˆ©/å¤±è´¥
    checkEndCondition();
  } else {
    // æ— æ•ˆäº¤æ¢åŠ¨ç”»
    await animateSwap(to, from);
  }

  gameState.isAnimating = false;
}

// --- åŠ¨ç”» ---
async function animateSwap(from, to) {
  const duration = 150;
  const startTime = Date.now();

  while (Date.now() - startTime < duration) {
    const progress = (Date.now() - startTime) / duration;
    render(from, to, progress);
    await sleep(16);
  }
  render();
}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// --- æ¸²æŸ“ ---
function render(swapFrom, swapTo, swapProgress) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // èƒŒæ™¯
  ctx.fillStyle = 'rgba(255,255,255,0.1)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  const offsetX = (canvas.width - BOARD_SIZE * CELL_SIZE - (BOARD_SIZE - 1) * CELL_GAP) / 2;
  const offsetY = (canvas.height - BOARD_SIZE * CELL_SIZE - (BOARD_SIZE - 1) * CELL_GAP) / 2;

  for (let r = 0; r < BOARD_SIZE; r++) {
    for (let c = 0; c < BOARD_SIZE; c++) {
      let x = offsetX + c * (CELL_SIZE + CELL_GAP);
      let y = offsetY + r * (CELL_SIZE + CELL_GAP);

      // å¤„ç†äº¤æ¢åŠ¨ç”»
      if (swapFrom && swapTo && swapProgress !== undefined) {
        if (swapFrom.row === r && swapFrom.col === c) {
          const tx = offsetX + swapTo.col * (CELL_SIZE + CELL_GAP);
          const ty = offsetY + swapTo.row * (CELL_SIZE + CELL_GAP);
          x = x + (tx - x) * swapProgress;
          y = y + (ty - y) * swapProgress;
        } else if (swapTo.row === r && swapTo.col === c) {
          const fx = offsetX + swapFrom.col * (CELL_SIZE + CELL_GAP);
          const fy = offsetY + swapFrom.row * (CELL_SIZE + CELL_GAP);
          x = x + (fx - x) * swapProgress;
          y = y + (fy - y) * swapProgress;
        }
      }

      const cell = gameState.board[r][c];

      // æ ¼å­èƒŒæ™¯
      ctx.fillStyle = 'rgba(255,255,255,0.15)';
      ctx.beginPath();
      ctx.roundRect(x, y, CELL_SIZE, CELL_SIZE, 8);
      ctx.fill();

      // è‹”è—“
      if (cell.blocker?.type === 'moss') {
        ctx.fillStyle = 'rgba(100, 150, 100, 0.6)';
        ctx.beginPath();
        ctx.roundRect(x + 4, y + 4, CELL_SIZE - 8, CELL_SIZE - 8, 6);
        ctx.fill();
      }

      // é€‰ä¸­é«˜äº®
      if (gameState.selectedCell && gameState.selectedCell.row === r && gameState.selectedCell.col === c) {
        ctx.strokeStyle = '#FFD700';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.roundRect(x, y, CELL_SIZE, CELL_SIZE, 8);
        ctx.stroke();
      }

      // Tile
      if (cell.tile) {
        const tile = cell.tile;

        // ç‰¹æ®Šå—èƒŒæ™¯
        if (tile.isSpecial) {
          ctx.fillStyle = SPECIAL_COLORS[tile.specialType];
          ctx.beginPath();
          ctx.arc(x + CELL_SIZE/2, y + CELL_SIZE/2, CELL_SIZE/2 - 4, 0, Math.PI * 2);
          ctx.fill();
        }

        // ç»˜åˆ¶ emoji
        ctx.font = '40px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(TILE_EMOJIS[tile.type], x + CELL_SIZE/2, y + CELL_SIZE/2 + 2);

        // ç‰¹æ®Šå—æ ‡è¯†
        if (tile.isSpecial) {
          ctx.font = '16px sans-serif';
          if (tile.specialType === 'lantern') {
            ctx.fillText('ğŸ’¥', x + CELL_SIZE - 12, y + 12);
          } else if (tile.specialType === 'whirl_h') {
            ctx.fillText('â†”', x + CELL_SIZE - 12, y + 12);
          } else {
            ctx.fillText('â†•', x + CELL_SIZE - 12, y + 12);
          }
        }
      }
    }
  }
}

// --- UI æ›´æ–° ---
function updateHUD() {
  document.getElementById('levelNum').textContent = gameState.level;
  document.getElementById('movesLeft').textContent = gameState.moves;
  document.getElementById('energy').textContent = `${gameState.energy.current}/${gameState.energy.max}`;

  const goal = gameState.goal;
  if (goal.type === 'collect') {
    document.getElementById('goalText').textContent =
      `æ”¶é›† ${TILE_EMOJIS[goal.item]} ${gameState.goalProgress}/${goal.count}`;
  } else {
    document.getElementById('goalText').textContent =
      `æ¸…é™¤è‹”è—“ ${gameState.goalProgress}/${goal.count}`;
  }

  // æ­¥æ•°è­¦å‘Š
  const movesEl = document.getElementById('movesLeft');
  if (gameState.moves <= 3) {
    movesEl.style.color = '#ff6b6b';
  } else {
    movesEl.style.color = '#fff';
  }
}

function showMessage(title, content, onClose) {
  document.getElementById('msgTitle').textContent = title;
  document.getElementById('msgContent').textContent = content;
  document.getElementById('messageBox').style.display = 'block';
  document.getElementById('msgBtn').onclick = () => {
    hideMessage();
    if (onClose) onClose();
  };
}

function hideMessage() {
  document.getElementById('messageBox').style.display = 'none';
}

function showCombo(count) {
  const el = document.getElementById('comboText');
  el.textContent = `è¿æ¶ˆ x${count}!`;
  el.style.opacity = 1;
  setTimeout(() => { el.style.opacity = 0; }, 800);
}

function checkEndCondition() {
  const goal = gameState.goal;
  const isComplete = gameState.goalProgress >= goal.count;

  if (isComplete) {
    // ä¿å­˜è¿›åº¦
    gameState.level++;
    saveEnergyState();

    // æ›´æ–°æ–°æ‰‹æç¤ºæ˜¾ç¤º
    const newbieHint = document.getElementById('newbieHint');
    if (gameState.level <= ENERGY_CONFIG.newbieProtection) {
      newbieHint.style.display = 'block';
    } else {
      newbieHint.style.display = 'none';
    }

    showMessage('æ­å–œé€šå…³!', `å‰©ä½™ ${gameState.moves} æ­¥`, () => {
      tryStartLevel(gameState.level);
    });
  } else if (gameState.moves <= 0) {
    showMessage('æŒ‘æˆ˜å¤±è´¥', 'å†è¯•ä¸€æ¬¡?', () => {
      tryStartLevel(gameState.level);
    });
  }
}

// --- è¾“å…¥å¤„ç† ---
let touchStart = null;

canvas.addEventListener('mousedown', (e) => {
  if (gameState.isAnimating) return;
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  const cell = positionToCell(x, y);
  if (cell) {
    if (gameState.selectedCell) {
      handleSwap(gameState.selectedCell, cell);
      gameState.selectedCell = null;
    } else {
      gameState.selectedCell = cell;
    }
    render();
  }
});

canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  if (gameState.isAnimating) return;
  const touch = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  touchStart = {
    x: touch.clientX - rect.left,
    y: touch.clientY - rect.top,
    cell: positionToCell(touch.clientX - rect.left, touch.clientY - rect.top)
  };
  if (touchStart.cell) {
    gameState.selectedCell = touchStart.cell;
    render();
  }
});

canvas.addEventListener('touchend', (e) => {
  e.preventDefault();
  if (!touchStart || !touchStart.cell || gameState.isAnimating) return;

  const touch = e.changedTouches[0];
  const rect = canvas.getBoundingClientRect();
  const endX = touch.clientX - rect.left;
  const endY = touch.clientY - rect.top;

  const dx = endX - touchStart.x;
  const dy = endY - touchStart.y;

  if (Math.abs(dx) > 20 || Math.abs(dy) > 20) {
    let targetCell;
    if (Math.abs(dx) > Math.abs(dy)) {
      targetCell = { row: touchStart.cell.row, col: touchStart.cell.col + (dx > 0 ? 1 : -1) };
    } else {
      targetCell = { row: touchStart.cell.row + (dy > 0 ? 1 : -1), col: touchStart.cell.col };
    }
    if (targetCell.row >= 0 && targetCell.row < BOARD_SIZE && targetCell.col >= 0 && targetCell.col < BOARD_SIZE) {
      handleSwap(touchStart.cell, targetCell);
    }
  }

  gameState.selectedCell = null;
  touchStart = null;
  render();
});

function positionToCell(x, y) {
  const offsetX = (canvas.width - BOARD_SIZE * CELL_SIZE - (BOARD_SIZE - 1) * CELL_GAP) / 2;
  const offsetY = (canvas.height - BOARD_SIZE * CELL_SIZE - (BOARD_SIZE - 1) * CELL_GAP) / 2;

  const col = Math.floor((x - offsetX) / (CELL_SIZE + CELL_GAP));
  const row = Math.floor((y - offsetY) / (CELL_SIZE + CELL_GAP));

  if (row >= 0 && row < BOARD_SIZE && col >= 0 && col < BOARD_SIZE) {
    return { row, col };
  }
  return null;
}

// --- æŒ‰é’®äº‹ä»¶ ---
document.getElementById('hintBtn').addEventListener('click', () => {
  const move = getValidMove();
  if (move) {
    gameState.selectedCell = move.from;
    render();
    setTimeout(() => {
      gameState.selectedCell = move.to;
      render();
      setTimeout(() => {
        gameState.selectedCell = null;
        render();
      }, 300);
    }, 300);
  }
});

document.getElementById('restartBtn').addEventListener('click', () => {
  tryStartLevel(gameState.level);
});

document.getElementById('nextBtn').addEventListener('click', () => {
  gameState.level++;
  saveEnergyState();
  tryStartLevel(gameState.level);
});

// ä½“åŠ›é—¨æ§›å¼¹çª—æŒ‰é’®
document.getElementById('watchAdBtn').addEventListener('click', () => {
  watchAdForEnergy();
  // å¹¿å‘Šçœ‹å®Œåå¦‚æœæœ‰ä½“åŠ›äº†ï¼Œè‡ªåŠ¨å…³é—­å¼¹çª—
  setTimeout(() => {
    if (gameState.energy.current > 0) {
      hideEnergyGate();
      tryStartLevel(gameState.level);
    }
  }, 2800);
});

document.getElementById('waitBtn').addEventListener('click', () => {
  hideEnergyGate();
});

// --- å¯åŠ¨æ¸¸æˆ ---
function startup() {
  // åŠ è½½å­˜æ¡£
  loadEnergyState();

  // æ˜¾ç¤ºæ–°æ‰‹ä¿æŠ¤æç¤º
  const newbieHint = document.getElementById('newbieHint');
  if (gameState.level <= ENERGY_CONFIG.newbieProtection) {
    newbieHint.style.display = 'block';
  } else {
    newbieHint.style.display = 'none';
  }

  // å¯åŠ¨ä½“åŠ›æ¢å¤å®šæ—¶å™¨
  startEnergyTimer();

  // å¼€å§‹æ¸¸æˆ
  tryStartLevel(gameState.level);
}

startup();
</script>
</body>
</html>
